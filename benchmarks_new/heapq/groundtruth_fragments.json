{"1": "heap.push(item);\n_siftdown(heap, 0, heap.length - 1);", "2": "var lastelt = heap.pop();\n    if (heap.length > 0) {\n        var returnitem = heap[0];\n        heap[0] = lastelt;\n        _siftup(heap, 0);\n        return returnitem;\n    }\n    return lastelt;", "3": "var returnitem = heap[0];\n    heap[0] = item;\n    _siftup(heap, 0);\n    return returnitem;", "4": "    if (heap.length > 0 && heap[0] < item) {\n        var temp = item;\n        item = heap[0];\n        heap[0] = temp;\n        _siftup(heap, 0);\n    }\n    return item;", "5": "var n = x.length;\n    for (var i = Math.floor(n / 2) - 1; i >= 0; i--) {\n        _siftup(x, i);\n    }", "6": "var lastelt = heap.pop();\n    if (heap.length > 0) {\n        var returnitem = heap[0];\n        heap[0] = lastelt;\n        _siftup_max(heap, 0);\n        return returnitem;\n    }\n    return lastelt;", "7": "var returnitem = heap[0];\n    heap[0] = item;\n    _siftup_max(heap, 0);\n    return returnitem;", "8": "var n = x.length;\n    for (var i = Math.floor(n / 2) - 1; i >= 0; i--) {\n        _siftup_max(x, i);\n    }", "9": "    var compare = require('./tracer_skip.js');\n    var newitem = heap[pos];\n    while (pos > startpos) {\n        var parentpos = (pos - 1) >> 1;\n        var parent = heap[parentpos];\n        if (compare(parent, newitem) > 0) {\n            heap[pos] = parent;\n            pos = parentpos;\n            continue;\n        }\n        break;\n    }\n    heap[pos] = newitem;", "10": "    var compare = require('./tracer_skip.js');\n    var endpos = heap.length;\n    var startpos = pos;\n    var newitem = heap[pos];\n    var childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n        var rightpos = childpos + 1;\n        if (rightpos < endpos && !(compare(heap[childpos], heap[rightpos]) < 0)) {\n            childpos = rightpos;\n        }\n        \n        heap[pos] = heap[childpos];\n        pos = childpos;\n        childpos = 2 * pos + 1;\n    }\n    heap[pos] = newitem;\n    _siftdown(heap, startpos, pos);", "11": "var newitem = heap[pos];\n    while (pos > startpos) {\n        var parentpos = (pos - 1) >> 1;\n        var parent = heap[parentpos];\n        if (parent[0] < newitem[0]) {\n            heap[pos] = parent;\n            pos = parentpos;\n            continue;\n        }\n        break;\n    }\n    heap[pos] = newitem;", "12": "var endpos = heap.length;\n    var startpos = pos;\n    var newitem = heap[pos];\n    var childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n        var rightpos = childpos + 1;\n        if (rightpos < endpos && !(heap[rightpos] < heap[childpos])) {\n            childpos = rightpos;\n        }\n        heap[pos] = heap[childpos];\n        pos = childpos;\n        childpos = 2 * pos + 1;\n    }\n    heap[pos] = newitem;\n    _siftdown_max(heap, startpos, pos);\n", "13": "h.push(x);", "14": "var h = [];\n    if (reverse) {\n        _heapify = _heapify_max;\n        _heappop = _heappop_max;\n        _heapreplace = _heapreplace_max;\n        direction = -1;\n    } else {\n        _heapify = heapify;\n        _heappop = heappop;\n        _heapreplace = heapreplace;\n        direction = 1;\n    }\n    for (var order = 0; order < iterables.length; order++) {\n        var it = iterables[order][Symbol.iterator]();\n        try {\n            var next = it.next.bind(it);\n            var next_elem = next();\n            if (next_elem.done) continue;\n            h_append([next_elem.value, order * direction, next]);\n        } catch (e) {\n            // pass\n            throw e;\n        }\n    }\n    order -= 1;\n    _heapify(h);\n    while (h.length > 1) {\n        try {\n            while (true) {\n                var s = h[0];\n                var [value, order, next] = s;\n                yield value;\n                var next_elem = next();\n                var done = next_elem.done;\n                if (done) {\n                    _heappop(h);\n                    break;\n                }\n                s[0] = next_elem.value;\n                _heapreplace(h, s);\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n    if (h.length > 0) {\n        var [value, order, next] = h[0];\n        yield value;\n        yield* (function* next_wrap() {\n            while(true) {\n                var next_elem = next(); \n                var val = next_elem.value;\n                var done = next_elem.done;\n                if (done) {\n                    break;\n                }\n                yield val;\n            };\n        })();\n    }\n    return;", "15": "if (n === 1) {\n    var it = iterable[Symbol.iterator]();\n    var sentinel = {};\n    var result = Math.min(...it);\n    return result === Infinity ? [] : [result];\n}\ntry {\n    var size = iterable.length;\n} catch (e) {\n    // pass\n}\nif (size !== undefined) {\n    if (n >= size) {\n        return iterable.slice().sort().slice(0, n);\n    }\n}\nit = iterable[Symbol.iterator]();\nresult = [];\nfor (var i = 0; i < n; i++) {\n    var elem = it.next().value;\n    if (elem !== undefined) {\n        result.push([elem, i]);\n    }\n}\nif (!result.length) {\n    return result;\n}\n_heapify_max(result);\nvar top = result[0][0];\nvar order = n;\nvar _heapreplace = _heapreplace_max;\nfor (elem of it) {\n    if (elem < top) {\n        _heapreplace(result, [elem, order]);\n        top = result[0][0];\n        order++;\n    }\n}\nresult.sort((a, b) => a[0] - b[0]);\nreturn result.map(function (x) { return x[0]; });", "16": "if (n === 1) {\n    var it = iterable[Symbol.iterator]();\n    var sentinel = {};\n    var result = Math.max(...iterable);\n    return result === -Infinity ? [] : [result];\n}\ntry {\n    var size = iterable.length;\n} catch (e) {\n    // pass\n}\nif (size !== undefined) {\n    if (n >= size) {\n        return iterable.slice().sort((a, b) => b - a).slice(0, n);\n    }\n}\nit = iterable[Symbol.iterator]();\nresult = [];\nfor (var i = 0; i < n; i++) {\n    var next = it.next();\n    if (next.done) break;\n    result.push([next.value, -i]);\n}\nif (!result.length) {\n    return result;\n}\nheapify(result);\nvar top = result[0][0];\nvar order = -n;\nvar _heapreplace = heapreplace;\nfor (var elem of it) {\n    if (top < elem) {\n        _heapreplace(result, [elem, order]);\n        top = result[0][0];\n        order = result[0][1];\n        order -= 1;\n    }\n}\nresult.sort((a, b) => b[0] - a[0]);\nreturn result.map(x => x[0]);", "17": "if (!(Math.abs(a - b) <= 0.0001)) {\n    throw new Error(\"Assertion failed: abs(a - b) <= 0.0001\");\n}", "18": "for (var index = 0; index < a.length; index++) {\n    assert_value_equal(a[index], b[index]);\n}", "19": "var heap = [];\n    for (var index = 0; index < items.length; index++) {\n        var item = items[index];\n        heappush(heap, item);\n    }\n    var a = heappop(heap);\n    var b = heappop(heap);\n    return [a, b];", "20": "    var tmp = test_heappush_help_function([6,1,-2,5]);\n    assert_equal(tmp,[-2,1]);\n    tmp = test_heappush_help_function([34,-3,-12,0]);\n    assert_equal(tmp,[-12,-3]);\n    tmp = test_heappush_help_function([5,4,3,2,1]);\n    assert_equal(tmp,[1,2]);\n    tmp = test_heappush_help_function([4.7,8,-1.2,7.2]);\n    assert_equal(tmp,[-1.2,4.7]);", "21": "    heapify(x);\n    var a = heappop(x);\n    var b = heappop(x);\n    return [a, b];", "22": "var tmp = test_heapify_help_function([6,1,-2,5]);\n    assert_equal(tmp,[-2,1]);\n    tmp = test_heapify_help_function([34,-3,-12,0]);\n    assert_equal(tmp,[-12,-3]);\n    tmp = test_heapify_help_function([5,4,3,2,1]);\n    assert_equal(tmp,[1,2]);\n    tmp = test_heapify_help_function([4.7,8,-1.2,7.2]);\n    assert_equal(tmp,[-1.2,4.7]);", "23": "heapify(x);\n    var a = heappushpop(x, i);\n    return a;", "24": "var tmp = test_heappushpop_help_function([6,1,-2,5],-5);\n    assert_value_equal(tmp,-5);\n    tmp = test_heappushpop_help_function([34,-3,-12,0],-13);\n    assert_value_equal(tmp,-13);\n    tmp = test_heappushpop_help_function([5,4,3,2,1],0);\n    assert_value_equal(tmp,0);\n    tmp = test_heappushpop_help_function([4.7,8,-1.2,7.2],9);\n    assert_value_equal(tmp,-1.2);\n", "25": "    heapify(x);\n    var a = heapreplace(x, i);\n    var b = heappop(x);\n    return [a, b];", "26": "tmp = test_heapreplace_help_function([6,1,-2,5], -5);\n    assert_equal(tmp, [-2, -5]);\n    tmp = test_heapreplace_help_function([34, -3, -12, 0], -13);\n    assert_equal(tmp, [-12, -13]);\n    tmp = test_heapreplace_help_function([5, 4, 3, 2, 1], 0);\n    assert_equal(tmp, [1, 0]);\n    tmp = test_heapreplace_help_function([4.7, 8, -1.2, 7.2], 9);\n    assert_equal(tmp, [-1.2, 4.7]);", "27": "tmp = Array.from(merge(false, [1,3,5,7], [0,2,4,8], [5,10,15,20], [], [25]));\n    assert_equal(tmp, [0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25]);\n    tmp = Array.from(merge(true, [7,5,3,1], [8,4,2,0]));\n    assert_equal(tmp, [8, 7, 5, 4, 3, 2, 1, 0]);", "28": "var tmp = nsmallest(1, [6,1,-2,5]);\n    assert_equal(tmp,[-2]);\n    tmp = nsmallest(2, [34,-3,-12,0]);\n    assert_equal(tmp,[-12,-3]);\n    tmp = nsmallest(2, [5,4,3,2,1]);\n    assert_equal(tmp,[1,2]);\n    tmp = nsmallest(2, [4.7,8,-1.2,7.2]);\n    assert_equal(tmp,[-1.2,4.7]);", "29": "tmp = nlargest(1, [6,1,-2,5])\n    assert_equal(tmp, [6])\n    tmp = nlargest(2, [34,-3,-12,0])\n    assert_equal(tmp, [34,0])\n    tmp = nlargest(2, [5,4,3,2,1])\n    assert_equal(tmp, [5,4])\n    tmp = nlargest(2, [4.7,8,-1.2,7.2])\n    assert_equal(tmp, [8,7.2])", "30": "test_heappush();\ntest_heapify();\ntest_heappushpop();\ntest_heapreplace();\ntest_nsmallest();\ntest_nlargest();\ntest_merge();\nadditional_tests();\n", "31": "var heap = [1];\n    var tmp = heappop(heap);\n    assert_value_equal(tmp, 1);\n    \n    heap = [1];\n    tmp = _heappop_max(heap);\n    assert_value_equal(tmp, 1);\n\n    tmp = nsmallest(0, [1]);\n    assert_equal(tmp, []);\n    \n    tmp = nsmallest(2, []);\n    assert_equal(tmp, []);\n\n    tmp = nsmallest(0, []);\n    assert_equal(tmp, []);\n\n    tmp = nlargest(0, [1]);\n    assert_equal(tmp, []);\n    \n    tmp = nlargest(2, []);\n    assert_equal(tmp, []);\n\n    tmp = nlargest(0, []);\n    assert_equal(tmp, []);\n\n    heap = [1, 2, 3];\n    tmp = _siftup_max(heap, 0);\n    assert_equal(heap, [3, 2, 1]);\n", "0": "test();\n"}