{"1": "s = s.replace(/&/g, \"&amp;\");\n    // Must be done first!\n    s = s.replace(/</g, \"&lt;\");\n    s = s.replace(/>/g, \"&gt;\");\n    if (quote) {\n        s = s.replace(/\"/g, \"&quot;\");\n        s = s.replace(/'/g, \"&#x27;\");\n    }\n    return s;\n", "2": "if (s[0] === '#') {\n    // numeric charref\n    var num;\n    if (s[1] === 'x' || s[1] === 'X') {\n        num = parseInt(s.slice(2).replace(';', ''), 16);\n    } else {\n        num = parseInt(s.slice(1).replace(';', ''));\n    }\n    if (('contains' in tool_functions._invalid_charrefs && tool_functions._invalid_charrefs.contains(num)) || (!('contains' in tool_functions._invalid_charrefs) && num in tool_functions._invalid_charrefs)) {\n        return tool_functions._invalid_charrefs[num];\n    }\n    if (0xD800 <= num && num <= 0xDFFF || num > 0x10FFFF) {\n        return '\\uFFFD';\n    }\n    if (('contains' in tool_functions._invalid_codepoints && tool_functions._invalid_codepoints.contains(num)) || (!('contains' in tool_functions._invalid_codepoints) && num in tool_functions._invalid_codepoints)) {\n        return '';\n    }\n    return String.fromCharCode(num);\n} else {\n    // named charref\n    if (('contains' in tool_functions._html5 && tool_functions._html5.contains(s)) || (!('contains' in tool_functions._html5) && s in tool_functions._html5)) {\n        return tool_functions._html5[s];\n    }\n    // find the longest matching name (as defined by the standard)\n    for (var x = s.length - 1; x > 1; x--) {\n        if (('contains' in tool_functions._html5 && tool_functions._html5.contains(s.substring(0, x))) || (!('contains' in tool_functions._html5) && s.substring(0, x) in tool_functions._html5)) {\n            return tool_functions._html5[s.substring(0, x)] + s.substring(x);\n        }\n    }\n    return '&' + s;\n}", "3": "    if (!s.includes('&')) {\n        return s;\n    }\n    var start = 0;\n    while (true) {\n        var match = _charref_regular_exp.exec(s);\n        if (!match) {\n            break;\n        }\n        var replacement = _replace_charref(match[1]);\n        s = s.substring(0, match.index) + replacement + s.substring(match.index + match[0].length);\n        start = match.index + replacement.length;\n        _charref_regular_exp.lastIndex = start;\n    }\n    return s;", "4": "return null;", "5": "class_var.lineno = 1;\nclass_var.offset = 0;", "6": "return [class_var.lineno, class_var.offset];", "7": "        if (i >= j) {\n            return j;\n        }\n        var rawdata = class_var.rawdata;\n        var nlines = (rawdata.substring(i, j).match(/\\n/g) || []).length;\n        if (nlines) {\n            class_var.lineno += nlines;\n            var pos = rawdata.lastIndexOf(\"\\n\", j);\n            class_var.offset = j - (pos + 1);\n        } else {\n            class_var.offset += j - i;\n        }\n        return j;", "8": "var rawdata = class_var.rawdata;\nvar j = i + 2;\nif (rawdata.substring(i, j) !== \"<!\") {\n    throw new Error(\"unexpected call to parse_declaration\");\n}\nif (rawdata.substring(j, j + 1) === \">\") {\n    // the empty comment <!>\n    return j + 1;\n}\nif ([\"-\", \"\"].includes(rawdata.substring(j, j + 1))) {\n    // Start of comment followed by buffer boundary,\n    // or just a buffer boundary.\n    return -1;\n}\n// A simple, practical version could look like: ((name|stringlit) S*) + '>'\nvar n = rawdata.length;\nif (rawdata.substring(j, j + 2) === '--') { //comment\n    // Locate --.*-- as the body of the comment\n    return class_var.parse_comment(i, 1);\n} else if (rawdata[j] === '[') { //marked section\n    // Locate [statusWord [...arbitrary SGML...]] as the body of the marked section\n    // Where statusWord is one of TEMP, CDATA, IGNORE, INCLUDE, RCDATA\n    // Note that this is extended by Microsoft Office \"Save as Web\" function\n    // to include [if...] and [endif].\n    return class_var.parse_marked_section(i, 1);\n} else { //all other declaration elements\n    var decltype_j = class_var._scan_name(j, i);\n    var decltype = decltype_j[0];\n    j = decltype_j[1];\n}\nif (j < 0) {\n    return j;\n}\nif (decltype === \"doctype\") {\n    class_var._decl_otherchars = '';\n}\nwhile (j < n) {\n    var c = rawdata[j];\n    if (c === \">\") {\n        // end of declaration syntax\n        var data = rawdata.substring(i + 2, j);\n        if (decltype === \"doctype\") {\n            class_var.handle_decl(data);\n        } else {\n            // According to the HTML5 specs sections \"8.2.4.44 Bogus\n            // comment state\" and \"8.2.4.45 Markup declaration open\n            // state\", a comment token should be emitted.\n            // Calling unknown_decl provides more flexibility though.\n            class_var.unknown_decl(data);\n        }\n        return j + 1;\n    }\n    if (c === \"\\\"\" || c === \"'\") {\n        var m = _declstringlit.exec(rawdata.substring(j));\n        if (!m) {\n            return -1; // incomplete\n        }\n        j += m[0].length;\n    } else if (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".includes(c)) {\n        var name_j = class_var._scan_name(j, i);\n        name = name_j[0];\n        j = name_j[1];\n    } else if (class_var._decl_otherchars.includes(c)) {\n        j = j + 1;\n    } else if (c === \"[\") {\n        // this could be handled in a separate doctype parser\n        if (decltype === \"doctype\") {\n            j = class_var._parse_doctype_subset(j + 1, i);\n        } else if ([\"attlist\", \"linktype\", \"link\", \"element\"].includes(decltype)) {\n            // must tolerate []'d groups in a content model in an element declaration\n            // also in data attribute specifications of attlist declaration\n            // also link type declaration subsets in linktype declarations\n            // also link attribute specification lists in link declarations\n            throw new Error(\"unsupported '[' char in \" + decltype + \" declaration\");\n        } else {\n            throw new Error(\"unexpected '[' char in declaration\");\n        }\n    } else {\n        throw new Error(\"unexpected \" + rawdata[j] + \" char in declaration\");\n    }\n    if (j < 0) {\n        return j;\n    }\n}\nreturn -1; // incomplete", "9": "var rawdata = class_var.rawdata;\n    if (rawdata.substring(i, i + 3) !== '<![') {\n        throw new Error(\"unexpected call to parse_marked_section()\");\n    }\n    var sectName_j = class_var._scan_name(i + 3, i);\n    var sectName = sectName_j[0];\n    var j = sectName_j[1];\n    if (j < 0) {\n        return j;\n    }\n    var standardSections = new Set([\"temp\", \"cdata\", \"ignore\", \"include\", \"rcdata\"]);\n    var msOfficeSections = new Set([\"if\", \"else\", \"endif\"]);\n    var match;\n    if (standardSections.has(sectName)) {\n        // look for standard ]]> ending\n        match = _markedsectionclose.exec(rawdata.substring(i + 3));\n    } else if (msOfficeSections.has(sectName)) {\n        // look for MS Office ]> ending\n        match = _msmarkedsectionclose.exec(rawdata.substring(i + 3));\n    } else {\n        throw new Error('unknown status keyword ' + rawdata.substring(i + 3, j) + ' in marked section');\n    }\n    if (!match) {\n        return -1;\n    }\n    if (report) {\n        j = match.index + i + 3;\n        class_var.unknown_decl(rawdata.substring(i + 3, j));\n    }\n    return match.index + match[0].length + i + 3;        \n            \n            \n            \n        ", "10": "var rawdata = class_var.rawdata;\n        if (rawdata.substring(i, i + 4) !== '<!--') {\n            throw new Error('unexpected call to parse_comment()');\n        }\n        var match = _commentclose.exec(rawdata.substring(i + 4));\n        if (!match) {\n            return -1;\n        }\n        if (report) {\n            var j = match.index;\n            class_var.handle_comment(rawdata.substring(i + 4, i + 4 + j));\n        }\n        return i + 4 + match.index + match[0].length;", "11": "var rawdata = class_var.rawdata;\nvar n = rawdata.length;\nvar j = i;\nwhile (j < n) {\n    var c = rawdata[j];\n    if (c === \"<\") {\n        var s = rawdata.substring(j, j + 2);\n        if (s === \"<\") {\n            // end of buffer; incomplete\n            return -1;\n        }\n        if (s !== \"<!\") {\n            class_var.updatepos(declstartpos, j + 1);\n            throw new AssertionError(\"unexpected char in internal subset (in \" + s + \")\");\n        }\n        if (j + 2 === n) {\n            // end of buffer; incomplete\n            return -1;\n        }\n        if (j + 4 > n) {\n            // end of buffer; incomplete\n            return -1;\n        }\n        if (rawdata.substring(j, j + 4) === \"<!--\") {\n            j = class_var.parse_comment(j, 0);\n            if (j < 0) {\n                return j;\n            }\n            continue;\n        }\n        var result = class_var._scan_name(j + 2, declstartpos);\n        var name = result[0];\n        j = result[1];\n        if (j === -1) {\n            return -1;\n        }\n        if (![\"attlist\", \"element\", \"entity\", \"notation\"].includes(name)) {\n            class_var.updatepos(declstartpos, j + 2);\n            throw new AssertionError(\"unknown declaration \" + name + \" in internal subset\");\n        }\n        // handle the individual names\n        var meth = class_var[\"_parse_doctype_\" + name];\n        j = meth(j, declstartpos);\n        if (j < 0) {\n            return j;\n        }\n    } else if (c === \"%\") {\n        // parameter entity reference\n        if (j + 1 === n) {\n            // end of buffer; incomplete\n            return -1;\n        }\n        var result = class_var._scan_name(j + 1, declstartpos);\n        s = result[0];\n        j = result[1];\n        if (j < 0) {\n            return j;\n        }\n        if (rawdata[j] === \";\") {\n            j = j + 1;\n        }\n    } else if (c === \"]\") {\n        j = j + 1;\n        while (j < n && /\\s/.test(rawdata[j])) {\n            j = j + 1;\n        }\n        if (j < n) {\n            if (rawdata[j] === \">\") {\n                return j;\n            }\n            class_var.updatepos(declstartpos, j);\n            throw new AssertionError(\"unexpected char after internal subset\");\n        } else {\n            return -1;\n        }\n    } else if (/\\s/.test(c)) {\n        j = j + 1;\n    } else {\n        class_var.updatepos(declstartpos, j);\n        throw new AssertionError(\"unexpected char \" + c + \" in internal subset\");\n    }\n}\n// end of buffer reached\nreturn -1;", "12": "var [name, j] = class_var._scan_name(i, declstartpos);\nif (j === -1) {\n    return -1;\n}\n// style content model; just skip until '>'\nvar rawdata = class_var.rawdata;\nif (rawdata.substring(j).includes('>')) {\n    return rawdata.indexOf(\">\", j) + 1;\n}\nreturn -1;", "13": "return null;", "14": "var name_j = class_var._scan_name(i, declstartpos);\nvar name = name_j[0];\nvar j = name_j[1];\nif (j < 0) {\n    return j;\n}\nvar rawdata = class_var.rawdata;\nwhile (true) {\n    var c = rawdata.substring(j, j + 1);\n    if (!c) {\n        // end of buffer; incomplete\n        return -1;\n    }\n    if (c === '>') {\n        return j + 1;\n    }\n    if (c === \"'\" || c === '\"') {\n        var m = _declstringlit.exec(rawdata.substring(j));\n        if (!m) {\n            return -1;\n        }\n        j += m[0].length;\n    } else {\n        var name_j = class_var._scan_name(j, declstartpos);\n        name = name_j[0];\n        j = name_j[1];\n        if (j < 0) {\n            return j;\n        }\n    }\n}", "15": "var rawdata = class_var.rawdata;\n    if (rawdata.substring(i, i + 1) === \"%\") {\n        var j = i + 1;\n        while (true) {\n            var c = rawdata.substring(j, j + 1);\n            if (!c) {\n                return -1;\n            }\n            if (/\\s/.test(c)) {\n                j++;\n            } else {\n                break;\n            }\n        }\n    } else {\n        j = i;\n    }\n    var name_j = class_var._scan_name(j, declstartpos);\n    var name = name_j[0];\n    j = name_j[1];\n    if (j < 0) {\n        return j;\n    }\n    while (true) {\n        c = rawdata.substring(j, j + 1);\n        if (!c) {\n            return -1;\n        }\n        if (\"'\\\"\".includes(c)) {\n            var m = _declstringlit.match(rawdata, j);\n            if (m) {\n                j = m.end();\n            } else {\n                return -1; // incomplete\n            }\n        } else if (c === \">\") {\n            return j + 1;\n        } else {\n            name_j = class_var._scan_name(j, declstartpos);\n            name = name_j[0];\n            j = name_j[1];\n            if (j < 0) {\n                return j;\n            }\n        }\n    }", "16": "var rawdata = class_var.rawdata;\nvar n = rawdata.length;\nif (i === n) {\n    return SCAN_NAME_DEFAULT;\n}\nvar m = _declname.exec(rawdata.substring(i));\nif (m) {\n    var s = m[0];\n    var name = s.trim();\n    if ((i + s.length) === n) {\n        return SCAN_NAME_DEFAULT;\n    }\n    return [name.toLowerCase(), m.index + i + s.length];\n} else {\n    class_var.updatepos(declstartpos, i);\n    throw new Error(\n        \"expected name token at \" + JSON.stringify(rawdata.substring(declstartpos, declstartpos + 20))\n    );\n}", "17": "        // pass", "18": "class_var.CDATA_CONTENT_ELEMENTS = CDATA_CONTENT_ELEMENTS;\nclass_var.convert_charrefs = convert_charrefs;\nclass_var.reset();", "19": "class_var.rawdata = '';\nclass_var.lasttag = '???';\nclass_var.interesting = interesting_normal;\nclass_var.cdata_elem = null;\n// ParserBase.reset(this); // This line is commented out as it refers to a method not defined in the provided context\nclass_var.lineno = 1;\nclass_var.offset = 0;", "20": "class_var.rawdata = class_var.rawdata + data;\nclass_var.goahead(0);", "21": "class_var.goahead(1);", "22": "return class_var.__starttag_text;", "23": "class_var.cdata_elem = elem.toLowerCase();\nclass_var.interesting = new RegExp('</\\\\s*' + class_var.cdata_elem + '\\\\s*>', 'i');\n", "24": "class_var.interesting = interesting_normal;\nclass_var.cdata_elem = null;\nreturn null;\n", "25": "            if (/^<[a-zA-Z]/.test(rawdata.substring(i))) { // < + letter\n                k = class_var.parse_starttag(i);\n            } else if (rawdata.startsWith(\"</\", i)) {\n                k = class_var.parse_endtag(i);\n            } else if (rawdata.startsWith(\"<!--\", i)) {\n                k = class_var.parse_comment(i, 1);\n            } else if (rawdata.startsWith(\"<?\", i)) {\n                k = class_var.parse_pi(i);\n            } else if (rawdata.startsWith(\"<!\", i)) {\n                k = class_var.parse_html_declaration(i);\n            } else if ((i + 1) < n) {\n                class_var.handle_data(\"<\");\n                k = i + 1;\n            } else {\n                return \"break\";\n            }\n            if (k < 0) {\n                if (!end) {\n                    return \"break\";\n                }\n                k = rawdata.indexOf('>', i + 1);\n                if (k < 0) {\n                    k = rawdata.indexOf('<', i + 1);\n                    if (k < 0) {\n                        k = i + 1;\n                    }\n                } else {\n                    k += 1;\n                }\n                if (class_var.convert_charrefs && !class_var.cdata_elem) {\n                    class_var.handle_data(unescape(rawdata.substring(i, k)));\n                } else {\n                    class_var.handle_data(rawdata.substring(i, k));\n                }\n            }\n            i = class_var.updatepos(i, k);", "26": "var match = charref.exec(rawdata.substring(i));\nif (match) {\n    var name = match[0].slice(2, -1);\n    class_var.handle_charref(name);\n    var k = match.index + i + match[0].length;\n    if (!rawdata.startsWith(';', k - 1)) {\n        k = k - 1;\n    }\n    i = class_var.updatepos(i, k);\n    return \"continue\";\n} else {\n    if (rawdata.substring(i).includes(\";\")) {  // bail by consuming &#\n        class_var.handle_data(rawdata.substring(i, i + 2));\n        i = class_var.updatepos(i, i + 2);\n    }\n    return \"break\";\n}", "27": "var match = entityref.exec(rawdata.substring(i));\nif (match) {\n    var name = match[1];\n    class_var.handle_entityref(name);\n    var k = i + match[0].length;\n    if (!rawdata.startsWith(';', k - 1)) {\n        k = k - 1;\n    }\n    i = class_var.updatepos(i, k);\n    return \"continue\";\n}\nmatch = incomplete.exec(rawdata.substring(i));\nif (match) {\n    if (end && match[0] === rawdata.substring(i)) {\n        k = i + match[0].length;\n        if (k <= i) {\n            k = n;\n        }\n        i = class_var.updatepos(i, i + 1);\n    }\n    return \"break\";\n} else if ((i + 1) < n) {\n    class_var.handle_data(\"&\");\n    i = class_var.updatepos(i, i + 1);\n} else {\n    return \"break\";\n}", "28": "var rawdata = class_var.rawdata;\nvar i = 0;\nvar n = rawdata.length;\nwhile (i < n) {\n    if (class_var.convert_charrefs && !class_var.cdata_elem) {\n        var j = rawdata.indexOf('<', i);\n        if (j < 0) {\n            var amppos = rawdata.lastIndexOf('&', Math.max(i, n - 34));\n            if (amppos >= 0 && !/[\\s;]/.test(rawdata.substring(amppos))) {\n                break;\n            }\n            j = n;\n        }\n    } else {\n        var match = class_var.interesting.exec(rawdata.substring(i));\n        if (match) {\n            j = match.index + i;\n        } else {\n            if (class_var.cdata_elem) {\n                break;\n            }\n            j = n;\n        }\n    }\n    if (i < j) {\n        if (class_var.convert_charrefs && !class_var.cdata_elem) {\n            class_var.handle_data(unescape(rawdata.substring(i, j)));\n        } else {\n            class_var.handle_data(rawdata.substring(i, j));\n        }\n    }\n    i = class_var.updatepos(i, j);\n    if (i == n) break;\n    if (rawdata.startsWith('<', i)) {\n        var act = handle_leftangle();\n        if (act === \"break\") {\n            break;\n        } else if (act === \"continue\") {\n            continue;\n        } else {\n            // pass\n        }\n    } else if (rawdata.startsWith(\"&#\", i)) {\n        var _act = handle_charref();\n        if (_act === \"break\") {\n            break;\n        } else if (_act === \"continue\") {\n            continue;\n        } else {\n            // pass\n        }\n    } else if (rawdata.startsWith('&', i)) {\n        var _act = handle_entityref();\n        if (_act === \"break\") {\n            break;\n        } else if (_act === \"continue\") {\n            continue;\n        } else {\n            // pass\n        }\n    } else {\n        throw new Error(\"interesting.search() lied\");\n    }\n}\nif (end && i < n && !class_var.cdata_elem) {\n    if (class_var.convert_charrefs && !class_var.cdata_elem) {\n        class_var.handle_data(unescape(rawdata.substring(i, n)));\n    } else {\n        class_var.handle_data(rawdata.substring(i, n));\n    }\n    i = class_var.updatepos(i, n);\n}\nclass_var.rawdata = rawdata.substring(i);", "29": "var rawdata = class_var.rawdata;\n    if (rawdata.substring(i, i + 2) !== '<!') {\n        throw new Error('unexpected call to parse_html_declaration()');\n    }\n    if (rawdata.substring(i, i + 4) === '<!--') {\n        // this case is actually already handled in goahead()\n        return class_var.parse_comment(i, 1);\n    } else if (rawdata.substring(i, i + 3) === '<![') {\n        return class_var.parse_marked_section(i, 1);\n    } else if (rawdata.substring(i, i + 9).toLowerCase() === '<!doctype') {\n        // find the closing >\n        var gtpos = rawdata.indexOf('>', i + 9);\n        if (gtpos === -1) {\n            return -1;\n        }\n        class_var.handle_decl(rawdata.substring(i + 2, gtpos));\n        return gtpos + 1;\n    } else {\n        return class_var.parse_bogus_comment(i, 1);\n    }", "30": "var rawdata = class_var.rawdata;\n    if (!(rawdata.substring(i, i + 2) === '<!' || rawdata.substring(i, i + 2) === '</')) {\n        throw new Error('unexpected call to parse_comment()');\n    }\n    var pos = rawdata.indexOf('>', i + 2);\n    if (pos === -1) {\n        return -1;\n    }\n    if (report) {\n        class_var.handle_comment(rawdata.substring(i + 2, pos));\n    }\n    return pos + 1;\n", "31": "var rawdata = class_var.rawdata;\n    if (rawdata.substring(i, i + 2) !== '<?') {\n        throw new Error('unexpected call to parse_pi()');\n    }\n    var match = tool_functions.piclose.exec(rawdata.substring(i + 2));\n    if (!match) {\n        return -1;\n    }\n    var j = match.index + i + 2;\n    class_var.handle_pi(rawdata.substring(i + 2, j));\n    j = match.index + match[0].length + i + 2;\n    return j;\n", "32": "        class_var.__starttag_text = null;\n        var endpos = class_var.check_for_whole_start_tag(i);\n        if (endpos < 0) {\n            var _return_value = endpos;\n            return _return_value;\n        }\n        rawdata = class_var.rawdata;\n        class_var.__starttag_text = rawdata.substring(i, endpos);\n    \n        // Now parse the data between i+1 and j into a tag and attrs\n    \n        var attrs = [];\n        var match = tagfind_tolerant.exec(rawdata.substring(i + 1));\n        if (!match) throw new Error('unexpected call to parse_starttag()');\n        k = match.index + match[0].length + i + 1;\n        class_var.lasttag = tag = match[1].toLowerCase();\n        while (k < endpos) {\n            var m = rawdata.slice(k-1).match(attrfind_tolerant);\n            if (m[2] == undefined) {\n                break;\n            }\n            var attrname = m[1], rest = m[2], attrvalue = m[3];\n            if (!rest) {\n                attrvalue = null;\n            } else if ((attrvalue[0] == \"'\" && attrvalue[attrvalue.length-1] == \"'\") || (attrvalue[0] == '\"' && attrvalue[attrvalue.length-1] == '\"')) {\n                attrvalue = attrvalue.slice(1, -1);\n            }\n            if (attrvalue) {\n                attrvalue = unescape(attrvalue);\n            }\n            attrs.push([attrname.toLowerCase(), attrvalue]);\n            k += m[0].length;\n        }\n    \n        var end = rawdata.substring(k, endpos).trim();\n        if (end !== \">\" && end !== \"/>\") {\n            class_var.handle_data(rawdata.substring(i, endpos));\n            var _return_value = endpos;\n            return _return_value;\n        }\n        if (end.endsWith('/>')) {\n            // XHTML-style empty tag: <span attr=\"value\" />\n            class_var.handle_startendtag(tag, attrs);\n        } else {\n            class_var.handle_starttag(tag, attrs);\n            if (tag === \"script\" || tag === \"style\") {\n                class_var.set_cdata_mode(tag);\n            }\n        }\n        var _return_value = endpos;\n        return _return_value;\n            \n            \n            \n        ", "33": "var rawdata = class_var.rawdata;\nvar m = locatestarttagend_tolerant.exec(rawdata.substring(i));\nif (m) {\n    var j = i + m.index + m[0].length;\n    var next = rawdata.substring(j, j + 1);\n    if (next === \">\") {\n        return j + 1;\n    }\n    if (next === \"/\") {\n        if (rawdata.startsWith(\"/>\", j)) {\n            return j + 2;\n        }\n        if (rawdata.startsWith(\"/\", j)) {\n            // buffer boundary\n            return -1;\n        }\n        // else bogus input\n        if (j > i) {\n            return j;\n        } else {\n            return i + 1;\n        }\n    }\n    if (next === \"\") {\n        // end of input\n        return -1;\n    }\n    if (\"abcdefghijklmnopqrstuvwxyz=/ABCDEFGHIJKLMNOPQRSTUVWXYZ\".includes(next)) {\n        // end of input in or before attribute value, or we have the\n        // '/' from a '/>' ending\n        return -1;\n    }\n    if (j > i) {\n        return j;\n    } else {\n        return i + 1;\n    }\n}\nthrow new Error(\"we should not get here!\");", "34": "var rawdata = class_var.rawdata;\n    if (rawdata.substring(i, i+2) !== \"</\") throw new Error(\"unexpected call to parse_endtag\");\n    var match = endendtag.exec(rawdata.substring(i+1));\n    if (!match) {\n        return -1;\n    }\n    var gtpos = match.index + match[0].length + i + 1;\n    match = endtagfind.exec(rawdata.substring(i));\n    if (!match) {\n        if (class_var.cdata_elem !== null) {\n            class_var.handle_data(rawdata.substring(i, gtpos));\n            return gtpos;\n        }\n        var namematch = tagfind_tolerant.exec(rawdata.substring(i+2));\n        if (!namematch) {\n            if (rawdata.substring(i, i+3) === '</>') {\n                return i+3;\n            } else {\n                return class_var.parse_bogus_comment(i, 1);\n            }\n        }\n        var tagname = namematch[1].toLowerCase();\n        gtpos = rawdata.indexOf('>', namematch.index + namematch[0].length + i + 2);\n        class_var.handle_endtag(tagname);\n        return gtpos + 1;\n    }\n    var elem = match[1].toLowerCase();\n    if (class_var.cdata_elem !== null) {\n        if (elem !== class_var.cdata_elem) {\n            class_var.handle_data(rawdata.substring(i, gtpos));\n            return gtpos;\n        }\n    }\n    class_var.handle_endtag(elem);\n    class_var.clear_cdata_mode();\n    return gtpos;", "35": "class_var.handle_starttag(tag, attrs);\nclass_var.handle_endtag(tag);", "36": "        return null;", "37": "        return null;", "38": "        return null;", "39": "        return null;", "40": "        return null;", "41": "        return null;", "42": "        return null;", "43": "        return null;", "44": "        return null;", "45": "console.log(\"Encountered a start tag:\", tag, attrs);\n    listener_event_list.push([\"starttag\", tag, attrs]);", "46": "console.log(\"Encountered an end tag :\", tag);\n    listener_event_list.push([\"endtag\", tag]);\n", "47": "console.log(\"Encountered some data  :\", data);\n    listener_event_list.push([\"data\", data]);", "48": "console.log(\"Encountered comment    :\", data);\n    listener_event_list.push([\"comment\", data]);", "49": "console.log(\"entityref:\", name)\n        listener_event_list.push([\"entityref\", name])", "50": "console.log(\"charref  name:\", name)\n        listener_event_list.push([\"charref\", name])", "51": "console.log(\"decl     data:\", data);\n    listener_event_list.push([\"decl\", data]);", "52": "console.log(\"pi       data:\", data);\n    listener_event_list.push([\"pi\", data]);", "53": "console.log(\"unknown  data:\", data);\n    listener_event_list.push([\"unknown\", data]);", "54": "    p = MyHTMLParserTester(true);\n    p.feed(_example_html);\n    // console.log(\"----- call functions -----\");\n    listener_event_list.push([\"PRINT\", p.getpos()]);\n    listener_event_list.push([\"PRINT\", p.get_starttag_text()]);\n    listener_event_list.push([\"PRINT\", p.parse_declaration(0)]);\n    p.close();", "55": "    p = MyHTMLParserTester(true);\n    p.rawdata = \"<!DOCTYPE html>\"\n    parse_res = p.parse_declaration(0)\n    console.assert(parse_res == 15)\n    p.reset()\n\n    p.rawdata = \"<!DOCTYPE '2'>\"\n    parse_res = p.parse_declaration(0)\n    console.assert(parse_res == 14)\n    p.reset()\n\n    p.rawdata = \"<!DOCTYPE [<!-->]> \"\n    parse_res = p.parse_declaration(0)\n    console.assert(parse_res == -1)\n    p.reset()\n\n    p.rawdata = \"<!DOCTYPE [%hello]> \"\n    parse_res = p.parse_declaration(0)\n    console.assert(parse_res == 19)\n    p.reset()\n\n    p.rawdata = \"<!DOCTYPE [ ]> \"\n    parse_res = p.parse_declaration(0)\n    console.assert(parse_res == 14)\n    p.reset()\n    p.close()", "56": "    p = MyHTMLParserTester(true)\n    p.convert_charrefs = false;\n    p.feed(\"&abc<\")\n    p.reset()\n\n    p.convert_charrefs = false;\n    p.feed(\"&#abc<\")\n    p.reset()\n\n    p.convert_charrefs = false;\n    p.feed(\"&<\")\n    p.reset()\n\n    p.convert_charrefs = false;\n    p.feed(\"&#<\")\n    p.reset()\n    p.close()", "57": "    p = MyHTMLParserTester(true)\n    p.handle_startendtag(\"tag\", [])\n    p.reset()\n    p.handle_charref(\"name\")\n    p.reset()\n    p.handle_entityref(\"name\")\n    p.reset()\n    p.handle_data(\"data\")\n    p.reset()\n    p.handle_comment(\"data\")\n    p.reset()\n    p.handle_decl(\"data\")\n    p.reset()\n    p.handle_pi(\"data\")\n    p.reset()\n    p.unknown_decl(\"data\")\n    p.reset()\n\n    p = HTMLParser(true)\n    p.handle_startendtag(\"tag\", [])\n    p.reset()\n    p.handle_charref(\"name\")\n    p.reset()\n    p.handle_entityref(\"name\")\n    p.reset()\n    p.handle_data(\"data\")\n    p.reset()\n    p.handle_comment(\"data\")\n    p.reset()\n    p.handle_decl(\"data\")\n    p.reset()\n    p.handle_pi(\"data\")\n    p.reset()\n    p.unknown_decl(\"data\")\n    p.reset()\n    p.close()", "58": "    p = HTMLParser(true)\n    p.rawdata = \"<abc/\"\n    parse_res = p.check_for_whole_start_tag(0)\n    console.assert(parse_res == -1)\n    p.reset()\n    p.rawdata = '<tagname attr=\"value'\n    parse_res = p.check_for_whole_start_tag(0)\n    console.assert(parse_res == -1)\n    p.reset()\n    p.rawdata = '<tagname attr'\n    parse_res = p.check_for_whole_start_tag(0)\n    console.assert(parse_res == -1)\n    p.reset()\n    p.rawdata = '<tagname /'\n    parse_res = p.check_for_whole_start_tag(0)\n    console.assert(parse_res == -1)\n    p.reset()\n    p.rawdata = '<tagname attr = \"value\" /'\n    parse_res = p.check_for_whole_start_tag(0)\n    console.assert(parse_res == -1)\n    p.reset()\n    p.rawdata = '<tagname \"value\" /'\n    parse_res = p.check_for_whole_start_tag(0)\n    console.assert(parse_res == -1)\n    p.reset()\n    p.close()", "59": "var res = escape(\"abc<>/'\", true)\n    console.assert(res == \"abc&lt;&gt;/&#x27;\")\n    res = escape(\"<>\", true)\n    console.assert(res == \"&lt;&gt;\")\n    res = escape(\"abc\", true)\n    console.assert(res == \"abc\")\n    res = escape(\"abc&\", true)\n    console.assert(res == \"abc&amp;\")\n\n    res = unescape(\"abc&lt;&gt;/&#x27;\")\n    console.assert(res == \"abc<>/'\")\n    res = unescape(\"&lt;&gt;\")\n    console.assert(res == \"<>\")\n    res = unescape(\"abc\")\n    console.assert(res == \"abc\")\n    res = unescape(\"abc&amp;\")\n    console.assert(res == \"abc&\")", "60": "    p = HTMLParser(true)\n    p.rawdata = \"element>\"\n    p._parse_doctype_element(0, 0)\n    p.reset()\n\n    p.rawdata = \"attlist element\"\n    p._parse_doctype_attlist(0, 0)\n    p.reset()\n\n    p.rawdata = \"notation element\"\n    p._parse_doctype_notation(0, 0)\n    p.reset()\n\n    p.rawdata = \"notation'\"\n    p._parse_doctype_notation(0, 0)\n    p.reset()\n\n    p.rawdata = \"%element element\"\n    p._parse_doctype_entity(0, 0)\n    p.reset()\n    p.close()", "61": "additional_test()\n    additional_test2()\n    additional_test3()\n    additional_test4()\n    additional_test5()\n    additional_test6()", "0": "name2codepoint = {\n    'AElig': 0x00c6\n};\ncodepoint2name = {};\nentitydefs = {};\nfor (var name in name2codepoint) {\n    var codepoint = name2codepoint[name];\n    codepoint2name[codepoint] = name;\n    entitydefs[name] = String.fromCharCode(codepoint);\n}\n\n_charref_regular_exp = tool_functions._charref_regular_exp\n_declname = tool_functions._declname\n\n_declstringlit = tool_functions._declstringlit\n_commentclose = tool_functions._commentclose\n_markedsectionclose = tool_functions._markedsectionclose\n_msmarkedsectionclose = tool_functions._msmarkedsectionclose\ninteresting_normal = tool_functions.interesting_normal\nincomplete = tool_functions.incomplete\nentityref = tool_functions.entityref\ncharref = tool_functions.charref\nstarttagopen = tool_functions.starttagopen\npiclose = tool_functions.piclose\ncommentclose = tool_functions.commentclose\ntagfind_tolerant = tool_functions.tagfind_tolerant\nattrfind_tolerant = tool_functions.attrfind_tolerant\nlocatestarttagend_tolerant = tool_functions.locatestarttagend_tolerant\nendendtag = tool_functions.endendtag\nendtagfind = tool_functions.endtagfind\n_example_html = tool_functions._example_html;\n\n_charref_regular_exp_match = _charref_regular_exp.exec\n_declname_match = _declname.exec\n_declstringlit_match = _declstringlit.exec\n_commentclose_match = _commentclose.exec\n_declstringlit_match = _declstringlit.exec\n_declname_match = _declname.exec\n_declstringlit_match = _declstringlit.exec\n_declstringlit_match = _declstringlit.exec\n_markedsectionclose_match = _markedsectionclose.exec\n_msmarkedsectionclose_match = _msmarkedsectionclose.exec\ninteresting_normal_match = interesting_normal.exec\nincomplete_match = incomplete.exec\nentityref_match = entityref.exec\ncharref_match = charref.exec\nstarttagopen_match = starttagopen.exec\npiclose_match = piclose.exec\ncommentclose_match = commentclose.exec\ntagfind_tolerant_match = tagfind_tolerant.exec\nattrfind_tolerant_match = attrfind_tolerant.exec\nlocatestarttagend_tolerant_match = locatestarttagend_tolerant.exec\nendendtag_match = endendtag.exec\nendtagfind_match = endtagfind.exec\nCDATA_CONTENT_ELEMENTS = [\"script\", \"style\"]\nSCAN_NAME_DEFAULT = [null, -1]\nlistener_event_list = [];\n\ntest();\nadditional_tests();\n"}