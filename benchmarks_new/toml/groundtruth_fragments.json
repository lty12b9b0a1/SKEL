{"1": "    if (typeof process !== 'undefined' && process.versions.node.split('.')[0] >= 4) {\n        pathlib = require('path');\n        if (user_check_type(p, pathlib)) {\n            return true;\n        }\n    }\n    return false;\n", "2": "if (typeof p === 'string' || p instanceof Buffer) {\n        return true;\n    }\n    return _detect_pathlib_path(p);\n", "3": "if (typeof p === 'string' || p instanceof String) {\n    return p;\n} else if (p instanceof URL) {\n    return p.pathname;\n} else {\n    return p.toString();\n}", "4": "var lineno = doc.substring(0, pos).split('\\n').length;\nvar colno = pos - doc.lastIndexOf('\\n', pos);\nvar emsg = msg + ' (line ' + lineno + ' column ' + colno + ' char ' + pos + ')';\nValueError.call(class_var, emsg);\nclass_var.msg = msg;\nclass_var.doc = doc;\nclass_var.pos = pos;\nclass_var.lineno = lineno;\nclass_var.colno = colno;", "5": "class_var.val = val;\nvar separator = beginline ? \"\\n\" : \" \";\nclass_var.comment = separator + comment;\nclass_var._dict = _dict;", "6": "return class_var.val[key];", "7": "class_var.val[key] = value;", "8": "var retstr = dump_value_func(class_var.val);\n    if (user_check_type(class_var.val, class_var._dict)) {\n        return class_var.comment + \"\\n\" + retstr.toString();\n    } else {\n        return retstr.toString() + class_var.comment;\n    }\n", "9": "n = n.trim();\n    if (!n) {\n        return false;\n    }\n    if (n[0] === '_') {\n        return false;\n    }\n    if (n[n.length - 1] === '_') {\n        return false;\n    }\n    if (n.includes(\"_.\") || n.includes(\"._\")) {\n        return false;\n    }\n    if (n.length === 1) {\n        return true;\n    }\n    if (n[0] === '0' && !['.', 'o', 'b', 'x'].includes(n[1])) {\n        return false;\n    }\n    if (n[0] === '+' || n[0] === '-') {\n        n = n.substring(1);\n        if (n.length > 1 && n[0] === '0' && n[1] !== '.') {\n            return false;\n        }\n    }\n    if (n.includes('__')) {\n        return false;\n    }\n    return true;", "10": "    // Not Reachable", "11": "key += item;\nif (item === '\\n') {\n    throw new TomlDecodeError(\"Key name found without value. Reached end of line.\", original, i);\n}\nif (openstring) {\n    if (item === openstrchar) {\n        var oddbackslash = false;\n        var k = 1;\n        while (i >= k && sl[i - k] === '\\\\') {\n            oddbackslash = !oddbackslash;\n            k += 1;\n        }\n        if (!oddbackslash) {\n            keyname = 2;\n            openstring = false;\n            openstrchar = \"\";\n        }\n    }\n    return \"continue\";\n} else if (keyname === 1) {\n    if (/\\s/.test(item)) {\n        keyname = 2;\n        return \"continue\";\n    } else if (item === '.') {\n        dottedkey = true;\n        return \"continue\";\n    } else if (/[\\w-]/.test(item)) { // \\w matches alphanumeric and underscore\n        return \"continue\";\n    } else if (dottedkey && sl[i - 1] === '.' && (item === '\"' || item === \"'\")) {\n        openstring = true;\n        openstrchar = item;\n        return \"continue\";\n    }\n} else if (keyname === 2) {\n    if (/\\s/.test(item)) {\n        if (dottedkey) {\n            var nextitem = sl[i + 1];\n            if (!/\\s/.test(nextitem) && nextitem !== '.') {\n                keyname = 1;\n            }\n        }\n        return \"continue\";\n    }\n    if (item === '.') {\n        dottedkey = true;\n        var nextitem = sl[i + 1];\n        if (!/\\s/.test(nextitem) && nextitem !== '.') {\n            keyname = 1;\n        }\n        return \"continue\";\n    }\n}\nif (item === '=') {\n    keyname = 0;\n    prev_key = key.slice(0, -1).trim();\n    key = '';\n    dottedkey = false;\n} else {\n    throw new TomlDecodeError(\"Found invalid character in key name: '\" + item + \"'. Try quoting the key name.\", original, i);\n}", "12": "var k = 1;\n        try {\n            while (sl[i - k] === \"'\") {\n                k += 1;\n                if (k === 3) {\n                    break;\n                }\n            }\n        } catch (error) {\n            if (error instanceof RangeError) {\n                // pass\n            } else {\n                throw error; // rethrow the error if it's not a RangeError\n            }\n        }\n        if (k === 3) {\n            multilinestr = !multilinestr;\n            openstring = multilinestr;\n        } else {\n            openstring = !openstring;\n        }\n        if (openstring) {\n            openstrchar = \"'\";\n        } else {\n            openstrchar = \"\";\n        }", "13": "var oddbackslash = false;\nvar k = 1;\nvar tripquote = false;\ntry {\n    while (sl[i - k] === '\"') {\n        k += 1;\n        if (k === 3) {\n            tripquote = true;\n            break;\n        }\n    }\n    if (k === 1 || (k === 3 && tripquote)) {\n        while (sl[i - k] === '\\\\') {\n            oddbackslash = !oddbackslash;\n            k += 1;\n        }\n    }\n} catch (error) {\n    if (error instanceof RangeError) {\n        // pass\n    } else {\n        throw error;\n    }\n}\nif (!oddbackslash) {\n    if (tripquote) {\n        multilinestr = !multilinestr;\n        openstring = multilinestr;\n    } else {\n        openstring = !openstring;\n    }\n}\nif (openstring) {\n    openstrchar = '\"';\n} else {\n    openstrchar = \"\";\n}", "14": "var j = i;\nvar comment = \"\";\ntry {\n    while (sl[j] !== '\\n') {\n        comment += sl[j];\n        sl[j] = ' ';\n        j++;\n    }\n} catch (error) {\n    if (error instanceof RangeError) {\n        return \"break\";\n    }\n}\nif (!openarr) {\n    decoder.preserve_comment(line_no, prev_key, comment, beginline);\n}", "15": "        if (item === '\\n') {\n            if (openstring || multilinestr) {\n                if (!multilinestr) {\n                    throw new TomlDecodeError(\"Unbalanced quotes\", original, i);\n                }\n                if ((sl[i - 1] === \"'\" || sl[i - 1] === '\"') && (sl[i - 2] === sl[i - 1])) {\n                    sl[i] = sl[i - 1];\n                    if (sl[i - 3] === sl[i - 1]) {\n                        sl[i - 3] = ' ';\n                    }\n                }\n            } else if (openarr) {\n                sl[i] = ' ';\n            } else {\n                beginline = true;\n            }\n            line_no++;\n        } else if (beginline && sl[i] !== ' ' && sl[i] !== '\\t') {\n            beginline = false;\n            if (!keygroup && !arrayoftables) {\n                if (sl[i] === '=') {\n                    throw new TomlDecodeError(\"Found empty keyname. \", original, i);\n                }\n                keyname = 1;\n                key += item;\n            }\n        }", "16": "        if (item === '[' && (!openstring && !keygroup &&\n        !arrayoftables)) {\n            if (beginline) {\n                if (sl.length > i + 1 && sl[i + 1] === '[') {\n                    arrayoftables = true;\n                } else {\n                    keygroup = true;\n                }\n            } else {\n                openarr += 1;\n            }\n        }\n        if (item === ']' && !openstring) {\n            if (keygroup) {\n                keygroup = false;\n            } else if (arrayoftables) {\n                if (sl[i - 1] === ']') {\n                    arrayoftables = false;\n                }\n            } else {\n                openarr -= 1;\n            }\n        }", "17": "            if (multibackslash) {\n                multilinestr += line;\n            } else {\n                multilinestr += line;\n            }\n            multibackslash = false;\n            var closed = false;\n            if (multilinestr[0] === '[') {\n                closed = line[line.length - 1] === ']';\n            } else if (line.length > 2) {\n                closed = (line[line.length - 1] === multilinestr[0] &&\n                          line[line.length - 2] === multilinestr[0] &&\n                          line[line.length - 3] === multilinestr[0]);\n            }\n            if (closed) {\n                try {\n                    var [value, vtype] = decoder.load_value(multilinestr, true);\n                } catch (err) {\n                    throw new TomlDecodeError(err.toString(), original, pos);\n                }\n                currentlevel[multikey] = value;\n                multikey = null;\n                multilinestr = \"\";\n            } else {\n                var k = multilinestr.length - 1;\n                while (k > -1 && multilinestr[k] === '\\\\') {\n                    multibackslash = !multibackslash;\n                    k -= 1;\n                }\n                if (multibackslash) {\n                    multilinestr = multilinestr.slice(0, -1);\n                } else {\n                    multilinestr += \"\\n\";\n                }\n            }\n            return \"continue\";", "18": "var i = 0;\nwhile (i < groups.length) {\n    groups[i] = groups[i].trim();\n    if (groups[i].length > 0 && (groups[i][0] === '\"' || groups[i][0] === \"'\")) {\n        var groupstr = groups[i];\n        var j = i + 1;\n        while ((groupstr[0] !== groupstr[groupstr.length - 1]) || groupstr.length === 1) {\n            j++;\n            if (j > groups.length + 2) {\n                throw new TomlDecodeError(\"Invalid group name '\" + groupstr + \"' Something went wrong.\", original, pos);\n            }\n            groupstr = groups.slice(i, j).join('.').trim();\n        }\n        groups[i] = groupstr.substring(1, groupstr.length - 1);\n        groups.splice(i + 1, j - (i + 1));\n    } else {\n        if (!_groupname_re.test(groups[i])) {\n            throw new TomlDecodeError(\"Invalid group name '\" + groups[i] + \"'. Try quoting it.\", original, pos);\n        }\n    }\n    i++;\n}", "19": "arrayoftables = false;\n    if (line.length === 1) {\n        throw new Error(\"Opening key group bracket on line by itself.\");\n    }\n\n    if (line[1] === '[') {\n        arrayoftables = true;\n        line = line.substring(2);\n        splitstr = ']]';\n    } else {\n        line = line.substring(1);\n        splitstr = ']';\n    }\n\n    var i = 1;\n    var quotesplits = decoder['_get_split_on_quotes'](line);\n    var quoted = false;\n    for (var quotesplit of quotesplits) {\n        if (!quoted && quotesplit.includes(splitstr)) {\n            break;\n        }\n        i += (quotesplit.match(new RegExp(splitstr, \"g\")) || []).length;\n        quoted = !quoted;\n    }\n\n    line = self_split(line, splitstr, i);\n\n    if (line.length < i + 1 || line[line.length - 1].trim() !== \"\") {\n        throw new Error(\"Key group not on a line by itself.\");\n    }\n    var groups = line.slice(0, -1).join(splitstr).split('.');\n    handle_groupname()\n    currentlevel = retval;\n    for (i = 0; i < groups.length; i++) {\n        var group = groups[i];\n        if (group === \"\") {\n            throw new Error(\"Can't have a keygroup with an empty name\");\n        }\n        try {\n            if (currentlevel.constructor.name === 'Array' && isNaN(parseInt(group))) {\n                throw new TypeError(\"abc\");\n            }\n            if (!currentlevel.hasOwnProperty(group)){\n                throw new RangeError(\"abc\")\n            }\n            if (i === groups.length - 1) {\n                if (implicitgroups.includes(group)) {\n                    implicitgroups.splice(implicitgroups.indexOf(group), 1);\n                    if (arrayoftables) {\n                        throw new Error(\"An implicitly defined table can't be an array\");\n                    }\n                } else if (arrayoftables) {\n                    currentlevel[group].push(decoder['get_empty_table']());\n                } else {\n                    throw new Error(\"What? \" + group + \" already exists?\" + JSON.stringify(currentlevel));\n                }\n            }\n        } catch (error) {\n            if (error instanceof TypeError) {\n                currentlevel = currentlevel[currentlevel.length - 1];\n                if (!(group in currentlevel)) {\n                    currentlevel[group] = decoder['get_empty_table']();\n                    if (i === groups.length - 1 && arrayoftables) {\n                        currentlevel[group] = [decoder['get_empty_table']()];\n                    }\n                }\n            } else if (error instanceof RangeError) {\n                if (i !== groups.length - 1) {\n                    implicitgroups.push(group);\n                }\n                currentlevel[group] = decoder['get_empty_table']();\n                if (i === groups.length - 1 && arrayoftables) {\n                    currentlevel[group] = [decoder['get_empty_table']()];\n                }\n            }\n        }\n        currentlevel = currentlevel[group];\n        if (arrayoftables) {\n            try {\n                currentlevel = currentlevel[currentlevel.length - 1];\n            } catch (KeyError) {\n                // pass\n            }\n        }\n    }\n", "20": "        var s = sl.join('');\n        s = s.split('\\n');\n        var multikey = null;\n        var multilinestr = \"\";\n        var multibackslash = false;\n        var pos = 0;\n        for (var idx = 0; idx < s.length; idx++) {\n            var line = s[idx];\n            if (idx > 0) {\n                pos += s[idx - 1].length + 1;\n            }\n            decoder.embed_comments(idx, currentlevel);\n            if (!multilinestr || multibackslash || !multilinestr.includes('\\n')) {\n                line = line.trim();\n            }\n            if (line === \"\" && (!multikey || multibackslash)) {\n                continue;\n            }\n            if (multikey) {\n                var act = handle_multikey();\n                if (act === \"continue\") {\n                    continue;\n                }\n            }\n            if (line[0] === '[') {\n                handle_start_bracket();\n            } else if (line[0] === \"{\") {\n                if (line[line.length - 1] !== \"}\") {\n                    throw new TomlDecodeError(\"Line breaks are not allowed in inline objects\", original, pos);\n                }\n                try {\n                    decoder.load_inline_object(line, currentlevel, multikey, multibackslash);\n                } catch (err) {\n                    throw new TomlDecodeError(err.toString(), original, pos);\n                }\n            } else if (line.includes(\"=\")) {\n                try {\n                    var ret = decoder.load_line(line, currentlevel, multikey, multibackslash);\n                } catch (err) {\n                    throw new TomlDecodeError(err.toString(), original, pos);\n                }\n                if (ret !== null) {\n                    multikey = ret[0];\n                    multilinestr = ret[1];\n                    multibackslash = ret[2];\n                }\n            }\n        }\n        return retval;", "21": "var implicitgroups = [];\n    if (decoder === null) {\n        decoder = new TomlDecoder(_dict);\n    }\n    var retval = decoder.get_empty_table();\n    var currentlevel = retval;\n    if (typeof s !== 'string') {\n        throw new TypeError(\"Expecting something like a string\");\n    }\n    var original = s;\n    var sl = s.split('');\n    var openarr = 0;\n    var openstring = false;\n    var openstrchar = \"\";\n    var multilinestr = false;\n    var arrayoftables = false;\n    var beginline = true;\n    var keygroup = false;\n    var dottedkey = false;\n    var keyname = 0;\n    var key = '';\n    var prev_key = '';\n    var line_no = 1;\n    for (var i = 0; i < sl.length; i++) {\n        var item = sl[i];\n        if (item === '\\r' && sl.length > (i + 1) && sl[i + 1] === '\\n') {\n            sl[i] = ' ';\n            continue;\n        }\n        if (keyname) {\n            var act = handle_keyname();\n            if (act === \"continue\") {\n                continue;\n            }\n        }\n        if (item === \"'\" && openstrchar !== '\"') {\n            handle_single_quote_1();\n        }\n        if (item === '\"' && openstrchar !== \"'\") {\n            handle_single_quote_2();\n        }\n        if (item === '#' && (!openstring && !keygroup && !arrayoftables)) {\n            act = handle_comment();\n            if (act === \"break\") {\n                break;\n            }\n        }\n        handle_bracket();\n        handle_backslash();\n    }\n    if (keyname) {\n        throw new TomlDecodeError(\"Key name found without value. Reached end of file.\", original, s.length);\n    }\n    if (openstring) {  // reached EOF and have an unterminated string\n        throw new TomlDecodeError(\"Unterminated string found. Reached end of file.\", original, s.length);\n    }\n    return handle_remaining();\n", "22": "var microsecond = 0;\nvar tz = null;\ntry {\n    if (val.length > 19) {\n        if (val[19] === '.') {\n            var subsecondval, tzval;\n            if (val[val.length - 1].toUpperCase() === 'Z') {\n                subsecondval = val.substring(20, val.length - 1);\n                tzval = \"Z\";\n            } else {\n                var subsecondvalandtz = val.substring(20);\n                var splitpoint;\n                if (subsecondvalandtz.includes('+')) {\n                    splitpoint = subsecondvalandtz.indexOf('+');\n                    subsecondval = subsecondvalandtz.substring(0, splitpoint);\n                    tzval = subsecondvalandtz.substring(splitpoint);\n                } else if (subsecondvalandtz.includes('-')) {\n                    splitpoint = subsecondvalandtz.indexOf('-');\n                    subsecondval = subsecondvalandtz.substring(0, splitpoint);\n                    tzval = subsecondvalandtz.substring(splitpoint);\n                } else {\n                    tzval = null;\n                    subsecondval = subsecondvalandtz;\n                }\n            }\n            if (tzval !== null) {\n                tz = new TomlTz(tzval);\n            }\n            microsecond = parseInt(parseInt(subsecondval) * Math.pow(10, (6 - subsecondval.length)));\n        } else {\n            tz = new TomlTz(val.substring(19).toUpperCase());\n        }\n    }\n} catch (e) {\n    tz = null;\n}\nif (!val.substring(1).includes(\"-\")) {\n    return null;\n}\nvar d = null;\ntry {\n    if (val.length === 10) {\n        d = new Date(Date.UTC(\n            parseInt(val.substring(0, 4)), parseInt(val.substring(5, 7)) - 1,\n            parseInt(val.substring(8, 10))));\n    } else {\n        d = new Date(Date.UTC(\n            parseInt(val.substring(0, 4)), parseInt(val.substring(5, 7)) - 1,\n            parseInt(val.substring(8, 10)), parseInt(val.substring(11, 13)),\n            parseInt(val.substring(14, 16)), parseInt(val.substring(17, 19)), microsecond));\n        // if (tz !== null) {\n        //     d = new Date(d.getTime() + tz.getOffset(d));\n        // }\n    }\n    d.tz = tz;\n    if (isNaN(d)) {\n        throw new Error(\"Invalid date\");\n    }\n} catch (e) {\n    return null;\n}\nreturn d;\n", "23": "var skip = false;\n    var i = v.length - 1;\n    while (i > -1 && v[i] === '\\\\') {\n        skip = !skip;\n        i -= 1;\n    }\n    for (var hx of hexbytes) {\n        if (skip) {\n            skip = false;\n            i = hx.length - 1;\n            while (i > -1 && hx[i] === '\\\\') {\n                skip = !skip;\n                i -= 1;\n            }\n            v += prefix;\n            v += hx;\n            continue;\n        }\n        var hxb = \"\";\n        i = 0;\n        var hxblen = 4;\n        if (prefix === \"\\\\U\") {\n            hxblen = 8;\n        }\n        hxb = hx.substring(i, i + hxblen).toLowerCase();\n        if (/[^0123456789abcdef]/.test(hxb)) {\n            throw new Error(\"Invalid escape sequence: \" + hxb);\n        }\n        if (hxb[0] === \"d\" && /[^01234567]/.test(hxb[1])) {\n            throw new Error(\"Invalid escape sequence: \" + hxb +\n            \". Only scalar unicode points are allowed.\");\n        }\n        v += unichr(parseInt(hxb, 16));\n        v += hx.substring(hxb.length);\n    }\n    return v;\n", "24": "var i = 0;\n    var backslash = false;\n    while (i < v.length) {\n        if (backslash) {\n            backslash = false;\n            if (_escapes.includes(v[i])) {\n                v = v.substring(0, i - 1) + _escape_to_escapedchars[v[i]] + v.substring(i + 1);\n            } else if (v[i] === '\\\\') {\n                v = v.substring(0, i - 1) + v.substring(i);\n            } else if (v[i] === 'u' || v[i] === 'U') {\n                i += 1;\n            } else {\n                throw new Error(\"Reserved escape sequence used\");\n            }\n            continue;\n        } else if (v[i] === '\\\\') {\n            backslash = true;\n        }\n        i += 1;\n    }\n    return v;\n", "25": "class_var._dict = _dict;\nreturn null;", "26": "return class_var._dict();", "27": "return DynamicInlineTableDict();\n", "28": "var candidate_groups = line.slice(1, -1).split(\",\");\nvar groups = [];\nif (candidate_groups.length === 1 && !candidate_groups[0].trim()) {\n    candidate_groups.pop();\n}\nwhile (candidate_groups.length > 0) {\n    var candidate_group = candidate_groups.shift();\n    var splitResult = candidate_group.split('=', 2);\n    if (splitResult.length < 2) {\n        throw new Error(\"Invalid inline table encountered\");\n    }\n    var value = splitResult[1].trim();\n    if ((value[0] === value[value.length - 1] && (\"'\\\"\".indexOf(value[0]) !== -1)) ||\n        ('-0123456789'.indexOf(value[0]) !== -1) ||\n        (value === 'true' || value === 'false') ||\n        (value[0] === \"[\" && value[value.length - 1] === \"]\") ||\n        (value[0] === '{' && value[value.length - 1] === '}')) {\n        groups.push(candidate_group);\n    } else if (candidate_groups.length > 0) {\n        candidate_groups[0] = candidate_group + \",\" + candidate_groups[0];\n    } else {\n        throw new Error(\"Invalid inline table value encountered\");\n    }\n}\nfor (var index = 0; index < groups.length; index++) {\n    var group = groups[index];\n    var status = class_var.load_line(group, currentlevel, multikey, multibackslash);\n    if (status !== null) {\n        break;\n    }\n}", "29": "var doublequotesplits = line.split('\"');\n    var quoted = false;\n    var quotesplits = [];\n    if (doublequotesplits.length > 1 && doublequotesplits[0].includes(\"'\")) {\n        var singlequotesplits = doublequotesplits[0].split(\"'\");\n        doublequotesplits = doublequotesplits.slice(1);\n        while (singlequotesplits.length % 2 === 0 && doublequotesplits.length) {\n            singlequotesplits[singlequotesplits.length - 1] += '\"' + doublequotesplits[0];\n            doublequotesplits = doublequotesplits.slice(1);\n            if (singlequotesplits[singlequotesplits.length - 1].includes(\"'\")) {\n                singlequotesplits = singlequotesplits.slice(0, -1).concat(singlequotesplits[singlequotesplits.length - 1].split(\"'\"));\n            }\n        }\n        quotesplits = quotesplits.concat(singlequotesplits);\n    }\n    doublequotesplits.forEach(function(doublequotesplit) {\n        if (quoted) {\n            quotesplits.push(doublequotesplit);\n        } else {\n            quotesplits = quotesplits.concat(doublequotesplit.split(\"'\"));\n            quoted = !quoted;\n        }\n    });\n    return quotesplits;\n", "30": "i = 1;\nvar quotesplits = class_var._get_split_on_quotes(line);\nvar quoted = false;\nfor (var quotesplit of quotesplits) {\n    if (!quoted && quotesplit.includes('=')) {\n        break;\n    }\n    i += (quotesplit.match(/=/g) || []).length;\n    quoted = !quoted;\n}\nvar pair = self_split(line, '=', i);\nvar strictly_valid = _strictly_valid_num(pair[pair.length - 1]);\nif (_number_with_underscores.test(pair[pair.length - 1]) && pair[pair.length - 1][0] !== \" \") {\n    pair[pair.length - 1] = pair[pair.length - 1].replace(/_/g, '');\n}\n\nwhile (pair[pair.length - 1].length > 0 && (pair[pair.length - 1][0] !== ' ' && pair[pair.length - 1][0] !== '\\t' &&\n    pair[pair.length - 1][0] !== \"'\" && pair[pair.length - 1][0] !== '\"' &&\n    pair[pair.length - 1][0] !== '[' && pair[pair.length - 1][0] !== '{' &&\n    pair[pair.length - 1].trim() !== 'true' && pair[pair.length - 1].trim() !== 'false')) {\n\n    if (!isNaN(parseFloat(pair[pair.length-1])) && ! pair[pair.length-1].includes(\"1979\") && ! pair[pair.length-1].includes(\"=\")) {\n        break\n    }\n\n    if (_load_date(pair[pair.length - 1]) !== null) {\n        break;\n    }\n    if (TIME_RE.test(pair[pair.length - 1])) {\n        break;\n    }\n    i++;\n    var prev_val = pair[pair.length - 1];\n    pair = self_split(line, '=', i);\n\n    if (prev_val === pair[pair.length - 1]) {\n        throw new Error(\"Invalid date or number\");\n    }\n    if (strictly_valid) {\n        strictly_valid = _strictly_valid_num(pair[pair.length - 1]);\n    }\n}\npair = [pair.slice(0, -1).join('=').trim(), pair[pair.length - 1].trim()];\nif (pair[0].includes('.')) {\n    if (pair[0].includes('\"') || pair[0].includes(\"'\")) {\n        quotesplits = class_var._get_split_on_quotes(pair[0]);\n        quoted = false;\n        var levels = [];\n        for (quotesplit of quotesplits) {\n            if (quoted) {\n                levels.push(quotesplit);\n            } else {\n                levels = levels.concat(quotesplit.split('.').map(level => level.trim()));\n            }\n            quoted = !quoted;\n        }\n    } else {\n        levels = pair[0].split('.').map(level => level.trim());\n    }\n    while (levels[levels.length - 1] === \"\") {\n        levels.pop();\n    }\n    for (var level of levels.slice(0, -1)) {\n        if (level === \"\") {\n            continue;\n        }\n        if (!(level in currentlevel)) {\n            currentlevel[level] = class_var.get_empty_table();\n        }\n        currentlevel = currentlevel[level];\n    }\n    pair[0] = levels[levels.length - 1];\n} else if ((pair[0][0] === '\"' || pair[0][0] === \"'\") && (pair[0][pair[0].length - 1] === pair[0][0])) {\n    pair[0] = _unescape(pair[0].substring(1, pair[0].length - 1));\n}\nvar k, koffset;\n_argument0 = pair[1];\n[k, koffset] = class_var._load_line_multiline_str(_argument0);\n\nif (k > -1) {\n    while (k > -1 && pair[1][k + koffset] === '\\\\') {\n        multibackslash = !multibackslash;\n        k--;\n    }\n    if (multibackslash) {\n        var multilinestr = pair[1].slice(0, -1);\n    } else {\n        var multilinestr = pair[1] + \"\\n\";\n    }\n    multikey = pair[0];\n} else {\n    var tmp;\n    tmp = class_var.load_value(pair[1].replace(), strictly_valid);\n    value = tmp[0];\n    vtype = tmp[1];\n}\n\n    if (currentlevel.hasOwnProperty(pair[0])){\n        throw new Error(\"Duplicate keys!\");\n    }\n    else{\n        if (multikey !== null && multikey !== false) {\n            var _return_value = [multikey, multilinestr, multibackslash];\n            return _return_value;\n        } else {\n            currentlevel[pair[0]] = value;\n        }\n    }\n\n        var _return_value = null;\n        return _return_value;\n", "31": "var poffset = 0;\n    if (p.length < 3) {\n        return [-1, poffset];\n    }\n    if (p[0] === '[' && (p.trim().slice(-1) !== ']' &&\n    class_var._load_array_isstrarray(p))) {\n        var newp = p.slice(1).trim().split(',');\n        while (newp.length > 1 && newp[newp.length - 1][0] !== '\"' && newp[newp.length - 1][0] !== \"'\") {\n            newp = newp.slice(0, -2).concat([newp[newp.length - 2] + ',' + newp[newp.length - 1]]);\n        }\n        newp = newp[newp.length - 1];\n        poffset = p.length - newp.length;\n        p = newp;\n    }\n    if (p[0] !== '\"' && p[0] !== \"'\") {\n        return [-1, poffset];\n    }\n    if (p[1] !== p[0] || p[2] !== p[0]) {\n        return [-1, poffset];\n    }\n    if (p.length > 5 && p[p.length - 1] === p[0] && p[p.length - 2] === p[0] && p[p.length - 3] === p[0]) {\n        return [-1, poffset];\n    }\n    return [p.length - 1, poffset];", "32": "if (parsed_date !== null) {\n    return [parsed_date, \"date\"];\n}\nif (!strictly_valid) {\n    throw new Error(\"Weirdness with leading zeroes or underscores in your number.\");\n}\nvar itype = \"int\";\nvar neg = false;\nif (v[0] === '-') {\n    neg = true;\n    v = v.substring(1);\n} else if (v[0] === '+') {\n    v = v.substring(1);\n}\nv = v.replace(/_/g, '');\nvar lowerv = v.toLowerCase();\nif (v.includes('.') || (!v.includes('x') && (v.includes('e') || v.includes('E')))) {\n    if (v.includes('.') && v.split('.', 2)[1] === '') {\n        throw new Error(\"This float is missing digits after the point\");\n    }\n    if (!'0123456789'.includes(v[0])) {\n        throw new Error(\"This float doesn't have a leading digit\");\n    }\n    v = parseFloat(v);\n    itype = \"float\";\n} else if (lowerv.length === 3 && (lowerv === 'inf' || lowerv === 'nan')) {\n    v = parseFloat(v);\n    itype = \"float\";\n}\nif (itype === \"int\") {\n    v = parseInt(v, 0);\n}\nif (neg) {\n    return [0 - v, itype];\n}\nreturn [v, itype];", "33": "        if (!v) {\n            throw new Error(\"Empty value is invalid\");\n        }\n        if (v === 'true') {\n            var _return_value = [true, \"bool\"];\n            return _return_value;\n        } else if (v.toLowerCase() === 'true') {\n            throw new Error(\"Only all lowercase booleans allowed\");\n        } else if (v === 'false') {\n            var _return_value = [false, \"bool\"];\n            return _return_value;\n        } else if (v.toLowerCase() === 'false') {\n            throw new Error(\"Only all lowercase booleans allowed\");\n        } else if (v[0] === '\"' || v[0] === \"'\") {\n            var quotechar = v[0];\n            var testv = v.slice(1).split(quotechar);\n            var triplequote = false;\n            var triplequotecount = 0;\n            if (testv.length > 1 && testv[0] === '' && testv[1] === '') {\n                testv = testv.slice(2);\n                triplequote = true;\n            }\n            var closed = false;\n            for (var tv of testv) {\n                if (tv === '') {\n                    if (triplequote) {\n                        triplequotecount += 1;\n                    } else {\n                        closed = true;\n                    }\n                } else {\n                    var oddbackslash = false;\n                    try {\n                        var i = -1;\n                        var j = tv[tv.length + i];\n                        while (j === '\\\\') {\n                            oddbackslash = !oddbackslash;\n                            i -= 1;\n                            j = tv[i];\n                        }\n                    } catch (error) {\n                        // Ignore IndexError\n                    }\n                    if (!oddbackslash) {\n                        if (closed) {\n                            throw new Error(\"Found tokens after a closed string. Invalid TOML.\");\n                        } else {\n                            if (!triplequote || triplequotecount > 1) {\n                                closed = true;\n                            } else {\n                                triplequotecount = 0;\n                            }\n                        }\n                    }\n                }\n            }\n    \n            if (quotechar === '\"') {\n                var escapeseqs = v.split('\\\\').slice(1);\n                var backslash = false;\n                for (var i of escapeseqs) {\n                    if (i === '') {\n                        backslash = !backslash;\n                    } else {\n                        if (!_escapes.includes(i[0]) && (i[0] !== 'u' && i[0] !== 'U' && !backslash)) {\n                            throw new Error(\"Reserved escape sequence used\");\n                        }\n                        if (backslash) {\n                            backslash = false;\n                        }\n                    }\n                }\n                for (var prefix of [\"\\\\u\", \"\\\\U\"]) {\n                    if (v.includes(prefix)) {\n                        var hexbytes = v.split(prefix);\n                        v = _load_unicode_escapes(hexbytes[0], hexbytes.slice(1), prefix);\n                    }\n                }\n                v = _unescape(v); // Assuming _unescape is similar to unescape\n            }\n            if (v.length > 1 && v[1] === quotechar && (v.length < 3 || v[1] === v[2])) {\n                v = v.slice(2, -2);\n            }\n            var _return_value = [v.slice(1, -1), \"str\"];\n            return _return_value;\n        } else if (v[0] === '[') {\n            var _return_value = [load_array(v), \"array\"]; // Assuming load_array is defined\n            return _return_value;\n        } else if (v[0] === '{') {\n            var inline_object = get_empty_inline_table(); // Assuming get_empty_inline_table is defined\n            load_inline_object(v, inline_object, false, false); // Assuming load_inline_object is defined\n            var _return_value = [inline_object, \"inline_object\"];\n            return _return_value;\n        } else if (TIME_RE.test(v)) {\n            var matches = TIME_RE.exec(v);\n            var h = matches[1], m = matches[2], s = matches[3], ms = matches[5] || 0;\n            var time = new Date(0, 0, 0, h, m, s, ms);\n            var _return_value = [time, \"time\"];\n            return _return_value;\n        } else {\n            var parsed_date = _load_date(v);\n            return handle_remaining();\n        }\n", "34": "if (s.length === 0) {\n    return true;\n}\nif (s[s.length - 1] !== s[0]) {\n    return false;\n}\nvar i = -2;\nvar backslash = false;\nwhile (s.length + i > 0) {\n    if (s[s.length + i] === \"\\\\\") {\n        backslash = !backslash;\n        i -= 1;\n    } else {\n        break;\n    }\n}\nreturn !backslash;", "35": "a = a.slice(1, -1).trim();\nif (a !== '' && (a[0] === '\"' || a[0] === \"'\")) {\n    return true;\n}\nreturn false;", "36": "        var retval = [];\n        a = a.trim();\n        if (!a.slice(1, -1).includes('[') || a.slice(1, -1).split('[')[0].trim() !== \"\") {\n            var strarray = class_var['_load_array_isstrarray'](a);\n            if (!a.slice(1, -1).trim().startsWith('{')) {\n                a = a.slice(1, -1).split(',');\n            } else {\n                var new_a = [];\n                var start_group_index = 1;\n                var end_group_index = 2;\n                var open_bracket_count = a[start_group_index] === '{' ? 1 : 0;\n                var in_str = false;\n                while (end_group_index < a.slice(1).length) {\n                    if (a[end_group_index] === '\"' || a[end_group_index] === \"'\") {\n                        if (in_str) {\n                            var backslash_index = end_group_index - 1;\n                            while (backslash_index > -1 && a[backslash_index] === '\\\\') {\n                                in_str = !in_str;\n                                backslash_index -= 1;\n                            }\n                        }\n                        in_str = !in_str;\n                    }\n                    if (!in_str && a[end_group_index] === '{') {\n                        open_bracket_count += 1;\n                    }\n                    if (in_str || a[end_group_index] !== '}') {\n                        end_group_index += 1;\n                        continue;\n                    } else if (a[end_group_index] === '}' && open_bracket_count > 1) {\n                        open_bracket_count -= 1;\n                        end_group_index += 1;\n                        continue;\n                    }\n    \n                    end_group_index += 1;\n    \n                    new_a.push(a.slice(start_group_index, end_group_index));\n    \n                    start_group_index = end_group_index + 1;\n                    while (start_group_index < a.slice(1).length && a[start_group_index] !== '{') {\n                        start_group_index += 1;\n                    }\n                    end_group_index = start_group_index + 1;\n                }\n                a = new_a;\n            }\n            var b = 0;\n            if (strarray) {\n                while (b < a.length - 1) {\n                    var ab = a[b].trim();\n                    while (!class_var['bounded_string'](ab) || (ab.length > 2 && ab[0] === ab[1] === ab[2] && ab[-2] !== ab[0] && ab[-3] !== ab[0])) {\n                        a[b] = a[b] + ',' + a[b + 1];\n                        ab = a[b].trim();\n                        if (b < a.length - 2) {\n                            a = a.slice(0, b + 1).concat(a.slice(b + 2));\n                        } else {\n                            a = a.slice(0, b + 1);\n                        }\n                    }\n                    b += 1;\n                }\n            }\n        } else {\n            var al = Array.from(a.slice(1, -1));\n            a = [];\n            var openarr = 0;\n            var j = 0;\n            for (var i = 0; i < al.length; i++) {\n                if (al[i] === '[') {\n                    openarr += 1;\n                } else if (al[i] === ']') {\n                    openarr -= 1;\n                } else if (al[i] === ',' && !openarr) {\n                    a.push(al.slice(j, i).join(''));\n                    j = i + 1;\n                }\n            }\n            a.push(al.slice(j).join(''));\n        }\n        for (var i = 0; i < a.length; i++) {\n            a[i] = a[i].trim();\n            if (a[i] !== '') {\n                var [nval, ntype] = class_var['load_value'](a[i], true);\n                retval.push(nval);\n            }\n        }\n        var _return_value = retval;\n        return _return_value;\n", "37": "        return null;", "38": "        return null;", "39": "class_var.saved_comments = {};\n\nreturn null;", "40": "class_var.saved_comments[line_no] = [key, comment, beginline];", "41": "if (!(idx in class_var.saved_comments)) {\n    return null;\n}\nvar [key, comment, beginline] = class_var.saved_comments[idx];\ncurrentlevel[key] = CommentValue(currentlevel[key], comment, beginline, class_var._dict);\n", "42": "if (!f.write) {\n        throw new TypeError(\"You can only dump an object to a file descriptor\");\n    }\n    var d = JSON.stringify(o, encoder);\n    f.write(d);\n    return d;\n", "43": "var retval = \"\";\n    if (encoder === null) {\n        encoder = new TomlEncoder(o.constructor, false);\n    }\n    var [addtoretval, sections] = encoder.dump_sections(o, \"\");\n    retval += addtoretval;\n    while (Object.keys(sections).length > 0) {\n        var newsections = encoder.get_empty_table();\n        for (var section in sections) {\n            var [addtoretval, addtosections] = encoder.dump_sections(sections[section], section);\n            if (addtoretval || (!addtoretval && Object.keys(addtosections).length === 0)) {\n                if (retval && retval.slice(-2) !== \"\\n\\n\") {\n                    retval += \"\\n\";\n                }\n                retval += \"[\" + section + \"]\\n\";\n                if (addtoretval) {\n                    retval += addtoretval;\n                }\n            }\n            for (var s in addtosections) {\n                newsections[section + \".\" + s] = addtosections[s];\n            }\n        }\n        sections = newsections;\n    }\n    return retval;", "44": "    v = JSON.stringify(v);\n    if (v[0] === 'u') {\n        v = v.substring(1);\n    }\n    var singlequote = v.startsWith(\"'\") || v.startsWith('`');\n    if (singlequote || v.startsWith('\"')) {\n        v = v.substring(1, v.length - 1);\n    }\n    if (singlequote) {\n        v = v.replace(/\\\\'/g, \"'\");\n        v = v.replace(/\"/g, '\\\\\"');\n    }\n    v = v.split(\"\\\\x\");\n    while (v.length > 1) {\n        var i = -1;\n        if (!v[0]) {\n            v = v.slice(1);\n        }\n        v[0] = v[0].replace(/\\\\\\\\/g, \"\\\\\");\n        var joinx = v[0][v[0].length + i] !== \"\\\\\";\n        while (v[0].slice(0, i) && v[0][v[0].length + i] === \"\\\\\") {\n            joinx = !joinx;\n            i -= 1;\n        }\n        var joiner = joinx ? \"x\" : \"u00\";\n        v = [v[0] + joiner + v[1]].concat(v.slice(2));\n    }\n    return '\"' + v[0] + '\"';\n", "45": "    if (v === Infinity) {\n        var _return_value = \"inf\";\n        return _return_value;\n    }\n    if (v === 1000000) {\n        var _return_value = v.toString() + \".0\";\n        return _return_value;\n    }\n    var _return_value = v.toString().replace(\"e+0\", \"e+\").replace(\"e-0\", \"e-\");\n    return _return_value;\n", "46": "var utcoffset = v.utcoffset();\n    if (utcoffset === null) {\n        return v.toISOString();\n    }\n    // The TOML norm specifies that it's local time thus we drop the offset\n    return v.toISOString().slice(0, -6);\n", "47": "    return String(v).toLowerCase();", "48": "return v;", "49": "return v.toISOString().replace('+00:00', 'Z');", "50": "    return v.toISOString();", "51": "class_var._dict = _dict;\nclass_var.preserve = preserve;\nclass_var.dump_funcs = {\n    \"str\": _dump_str,\n    \"list\": class_var.dump_list,\n    \"bool\": _dump_bool,\n    \"int\": _dump_int,\n    \"float\": _dump_float,\n};", "52": "return class_var._dict();", "53": "var retval = \"[\";\n    for (var u of v) {\n        retval += \" \" + class_var.dump_value(u) + \",\";\n    }\n    retval += \"]\";\n    return retval;", "54": "var retval = \"\";\n    if (section instanceof Object && !Array.isArray(section)) {\n        var val_list = [];\n        for (var k in section) {\n            if (section.hasOwnProperty(k)) {\n                var v = section[k];\n                var val = class_var.dump_inline_table(v);\n                val_list.push(k + \" = \" + val);\n            }\n        }\n        retval += \"{ \" + val_list.join(\", \") + \" }\\n\";\n        return retval;\n    } else {\n        return String(class_var.dump_value(section));\n    }\n", "55": "var dump_fn = null;\nfor (var t in class_var.dump_funcs) {\n    if (user_check_type(v, t)) {\n        dump_fn = class_var.dump_funcs[t];\n        break;\n    }\n}\nif (dump_fn === null && v !== null && typeof v === 'object' && typeof v[Symbol.iterator] === 'function') {\n    dump_fn = class_var.dump_funcs['list'];\n}\nif (dump_fn === null) {\n    dump_fn = class_var.dump_funcs['str'];\n}\n\nreturn (typeof dump_fn === 'function') ? dump_fn(v) : class_var.dump_funcs['str'](v);\n", "56": "        var retstr = \"\";\n        if (sup !== \"\" && sup.slice(-1) !== \".\") {\n            sup += '.';\n        }\n        var retdict = class_var._dict();\n        var arraystr = \"\";\n        for (var section in o) {\n            section = String(section);\n                var qsection = section;\n                if (!/^[A-Za-z0-9_-]+$/.test(section)) {\n                    qsection = _dump_str(section);\n                }\n        \n                if (o[section]._class_name === \"CommentValue\" || (!(o[section] instanceof Object) || o[section].constructor.name === \"Date\") || Array.isArray(o[section])) {\n                    var arrayoftables = false;\n                    if (Array.isArray(o[section])) {\n                        for (var a of o[section]) {\n                            if (a instanceof Object && !Array.isArray(a)) {\n                                arrayoftables = true;\n                            }\n                        }\n                    }\n        \n                    if (arrayoftables) {\n                        for (var a of o[section]) {\n                            var arraytabstr = \"\\n\";\n                            arraystr += \"[[\" + sup + qsection + \"]]\\n\";\n                            var [s, d] = class_var.dump_sections(a, sup + qsection);\n                            if (s) {\n                                if (s[0] === \"[\") {\n                                    arraytabstr += s;\n                                } else {\n                                    arraystr += s;\n                                }\n                            }\n                            while (Object.keys(d).length !== 0) {\n                                var newd = class_var._dict();\n                                for (var dsec in d) {\n                                    var [s1, d1] = class_var.dump_sections(d[dsec], sup + qsection + \".\" + dsec);\n                                    if (s1) {\n                                        arraytabstr += (\"[\" + sup + qsection + \".\" + dsec + \"]\\n\");\n                                        arraytabstr += s1;\n                                    }\n                                    for (var s1 in d1) {\n                                        newd[dsec + \".\" + s1] = d1[s1];\n                                    }\n                                }\n                                d = newd;\n                            }\n                            arraystr += arraytabstr;\n                        }\n                    } else {\n                        if (o[section] !== null) {\n                            retstr += (qsection + \" = \" + String(class_var.dump_value(o[section])) + '\\n');\n                        }\n                    }\n                } else if (class_var.preserve && (o[section] instanceof Object)) {\n                    retstr += (qsection + \" = \" + class_var.dump_inline_table(o[section]));\n                } else {\n                    retdict[qsection] = o[section];\n                }\n        }\n        retstr += arraystr;\n        return [retstr, retdict];\n", "57": "        \n        // pass", "58": "if (separator.trim() === \"\") {\n    separator = \",\" + separator;\n} else if (separator.trim().replace(/[\\s,]/g, '')) {\n    throw new Error(\"Invalid separator for arrays\");\n}\nclass_var.separator = separator;", "59": "var t = [];\n    var retval = \"[\";\n    for (var u of v) {\n        t.push(class_var.dump_value(u));\n    }\n    while (t.length !== 0) {\n        var s = [];\n        for (var u of t) {\n            if (Array.isArray(u)) {\n                for (var r of u) {\n                    s.push(r);\n                }\n            } else {\n                retval += \" \" + String(u) + class_var.separator;\n            }\n        }\n        t = s;\n    }\n    retval += \"]\";\n    return retval;\n", "60": "class_var.dump_funcs[\"float16\"] = _dump_float;\nclass_var.dump_funcs[\"float32\"] = _dump_float;\nclass_var.dump_funcs[\"float64\"] = _dump_float;\nclass_var.dump_funcs[\"int16\"] = class_var._dump_int;\nclass_var.dump_funcs[\"int32\"] = class_var._dump_int;\nclass_var.dump_funcs[\"int64\"] = class_var._dump_int;", "61": "return v.toString();", "62": "class_var.dump_funcs[\"CommentValue\"] = function(v) { return v.dump(class_var.dump_value); };", "63": "return _dump_str(String(v));", "64": "if (Number(process.versions.node.split('.')[0]) >= 12) {\n    pathlib = require('path');\n    if (user_check_type(v, pathlib.PurePath)) {\n        v = String(v);\n    }\n}\nreturn TomlEncoder(TomlPathlibEncoder, class_var).dump_value(v);", "65": "        \n        // pass", "66": "        \n        // pass", "67": "if (toml_offset === \"Z\") {\n    class_var._raw_offset = \"+00:00\";\n} else {\n    class_var._raw_offset = toml_offset;\n}\nclass_var._sign = class_var._raw_offset[0] === '-' ? -1 : 1;\nclass_var._hours = parseInt(class_var._raw_offset.substring(1, 3));\nif (class_var._raw_offset.substring(1, 3).includes(\"_\")) {\n    throw new Error(\"invalid literal for int() with base 10: '\" + class_var._raw_offset.substring(1, 3) + \"'\");\n}\nclass_var._minutes = parseInt(class_var._raw_offset.substring(4, 6));\nif (class_var._raw_offset.substring(4, 6).includes(\"_\")) {\n    throw new Error(\"invalid literal for int() with base 10: '\" + class_var._raw_offset.substring(4, 6) + \"'\");\n}\n", "68": "return [class_var._raw_offset];", "69": "return new class_var.constructor(class_var._raw_offset);", "70": "return \"UTC\" + class_var._raw_offset;", "71": "return class_var._sign * (class_var._hours * 3600000 + class_var._minutes * 60000);", "72": "return 0;", "73": "if (Array.isArray(v)) {\n        var _return_value = v.map(vv => convert(vv));\n        return _return_value;\n    } else if (v['type'] === undefined || v['value'] === undefined) {\n        var _return_value = {};\n        for (var k in v) {\n            _return_value[k] = convert(v[k]);\n        }\n        return _return_value;\n    } else if (v['type'] === 'string') {\n        var _return_value = v['value'];\n        return _return_value;\n    } else if (v['type'] === 'integer') {\n        var _return_value = parseInt(v['value']);\n        return _return_value;\n    } else if (v['type'] === 'float') {\n        if (v['value'] === 'inf') {\n            var _return_value = Infinity;\n            return _return_value;\n        }\n        var _return_value = parseFloat(v['value']);\n        return _return_value;\n    } else if (v['type'] === 'bool') {\n        var _return_value = v['value'] === 'true';\n        return _return_value;\n    } else if (['datetime', 'datetime-local', 'date-local', 'time-local'].includes(v['type'])) {\n        var _return_value = loads('a=' + v['value'], func_dict, null)['a']\n        return _return_value\n    } else {\n        throw new Error('unknown type: ' + v['type']);\n    }", "74": "if (value instanceof Object && !(value instanceof Array) && !(value instanceof Date) && !(value instanceof String) && !(value instanceof Boolean) && !(value instanceof Number)) {\n        var _return_value = {};\n        for (var k in value) {\n            if (value.hasOwnProperty(k)) {\n                _return_value[k] = tag(value[k]);\n            }\n        }\n        return _return_value;\n    } else if (value instanceof Array) {\n        var _return_value = value.map(function(v) { return tag(v); });\n        return _return_value;\n    } else if (typeof value === 'string') {\n        var _return_value = {'type': 'string', 'value': value};\n        return _return_value;\n    } else if (typeof value === 'boolean') {\n        var _return_value = {'type': 'bool', 'value': value.toString().toLowerCase()};\n        return _return_value;\n    } else if (typeof value === 'number' && Number.isSafeInteger(value) && value !== 1000000) {\n        var _return_value = {'type': 'integer', 'value': value.toString()};\n        return _return_value;\n    } else if (typeof value === 'number' && (!Number.isSafeInteger(value) || value === 1000000)) {\n        if (value === Infinity) {\n            var _return_value = {'type': 'float', 'value': \"inf\"};\n        }\n        else if (Number.isSafeInteger(value)) {\n            var _return_value = {'type': 'float', 'value': value.toString() + '.0'};\n        }\n        else{\n            var _return_value = {'type': 'float', 'value': value.toString()};\n        }\n        return _return_value;\n    } else if (value instanceof Date) {\n        \n        if (value.getUTCHours() === 0 && value.getUTCMinutes() === 0 && value.getUTCSeconds() === 0 && value.getUTCMilliseconds() === 0) {\n            var _return_value = {'type': 'date-local', 'value': value.toISOString().substring(0, 10)};\n        } \n        else if (value.getUTCSeconds() === 0 && value.getUTCMilliseconds() === 0) {\n            var _tzinfo = value.tz.utcoffset(\"0\")[0];\n            if (_tzinfo === 0){\n                var _return_value = {'type': 'datetime', 'value': value.toISOString().substring(0, 19) + \"Z\"};\n            }\n            else{\n                var offset = _tzinfo / 3600 / 1000;\n                var _return_value = {'type': 'datetime', 'value': value.toISOString().substring(0, 19) + \"-0\" + (-offset).toString() +  \":00\"};\n            }\n        }\n        else{\n            var _tzinfo = value.tz.utcoffset(\"0\")[0];\n            var offset = _tzinfo / 3600 / 1000;\n            var _return_value = {'type': 'datetime', 'value': value.toISOString().substring(0, 19) + \"-0\" + (-offset).toString() +  \":00\"};\n        }\n        return _return_value;\n    } else {\n        throw new Error('Unknown type: ' + (typeof value));\n    }", "75": "decode_input = tool_functions.get_input(name)\n    decode_result = loads(decode_input, func_dict, null)\n    decode_result = tag(decode_result)\n\n    var encode_input = {};\n    for (var k in decode_result) {\n        if (decode_result.hasOwnProperty(k)) {\n            var v = convert(decode_result[k]);\n            encode_input[k] = v;\n        }\n    }\n\n    encode_result = dumps(encode_input, null)", "76": "console.assert('a = \"\\\\u0064\"\\n' == dumps({'a': '\\\\x64'}, null))\n    console.assert('a = \"\\\\\\\\x64\"\\n' == dumps({'a': '\\\\\\\\x64'}, null))\n    console.assert('a = \"\\\\\\\\\\\\u0064\"\\n' == dumps({'a': '\\\\\\\\\\\\x64'}, null))", "77": "console.assert(loads(TEST_STR, func_dict, null) instanceof Object)", "78": "_test_dict_decoder = TomlDecoder(func_dict)\n    console.assert((loads(TEST_STR, func_dict, _test_dict_decoder) instanceof Object))", "79": "encoder = TomlArraySeparatorEncoder(func_dict, false, \",\\t\")\n    d = {\"a\": [1, 2, 3]}\n    tmp = dumps(d, encoder)\n    o = loads(tmp, func_dict, null)\n    tmp2 = dumps(o, encoder)\n    console.assert(JSON.stringify(o) === JSON.stringify(loads(tmp2, func_dict, null)))", "80": "d = {\"a\": [3, 4]}\n    var encoder = TomlEncoder(func_dict, false)\n    tmp = dumps(d, encoder)\n    o = loads(tmp, func_dict, null)\n    tmp2 = dumps(o, encoder)\n    console.assert(JSON.stringify(o) === JSON.stringify(loads(tmp2, func_dict, null)))", "81": "var encoder = TomlEncoder(func_dict, false)\n    tmp = dumps(TEST_DICT, encoder)\n    o = loads(tmp, func_dict, null)\n    tmp2 = dumps(o, encoder)\n    console.assert(JSON.stringify(o) === JSON.stringify(loads(tmp2, func_dict, null)))\n", "82": "tmp = loads(tool_functions.test_str, func_dict, TomlPreserveCommentDecoder(func_dict))\n    s = dumps(tmp, TomlPreserveCommentEncoder(func_dict, false))\n    if (\n        s.length === test_str.length &&\n        [...s].sort().join('') === [...test_str].sort().join('')\n    ) {\n        console.log(\"Assertion passed!\");\n    } else {\n        console.error(\"Assertion failed!\");\n    }", "83": "tester(\"Comment\")\n    tester(\"Boolean\")\n    tester(\"Integer\")\n    tester(\"Float\")\n    tester(\"Table\")\n    tester(\"Inline Table\")\n    tester(\"String\")\n    // tester(\"Datetime\")\n    tester(\"Array\")\n    tester(\"Array of Tables\")\n    test_bug_148()\n    test__dict()\n    test_dict_decoder()\n    test_array_sep()\n    test_tuple()\n    test_commutativity()\n    test_comment_preserve_decoder_encoder()\n    additional_test()\n    additional_test2()\n    additional_test3()\n    additional_test4()\n    additional_test5()", "84": "return String.fromCharCode(s);", "85": "var decoder = new TomlDecoder(func_dict);\n    var cur = {};\n    var multikey = false;\n    var multibackslash = false;\n    decoder.load_line(\"'a.x'=2=3\", cur, multikey, multibackslash);\n    console.assert(JSON.stringify(cur) === JSON.stringify({'a.x': {'=2': 3}}));", "86": "var decoder = new TomlDecoder(func_dict);\n    var res = decoder.load_array(\"[{'x' = 1}]\");\n    console.assert(JSON.stringify(res) === JSON.stringify([{'x': 1}]));\n    \n    res = decoder.load_array(\"[{'x' = 1}, {'y' = 2}]\");\n    console.assert(JSON.stringify(res) === JSON.stringify([{'x': 1}, {'y': 2}]));", "87": "var v = \"abc\\\\\";\n    var hexbytes = ['0064'];\n    var prefix = 'u';\n    var res = _load_unicode_escapes(v, hexbytes, prefix);\n    console.assert(res === 'abc\\\\u0064');", "88": "var v = \"\\\\\\\\\";\n    var res = _unescape(v);\n    console.assert(res === '\\\\');\n    \n    v = \"\\\\u\";\n    res = _unescape(v);\n    console.assert(res === '\\\\u');\n", "89": "var s = \"['\\\"test\\\"']\";\n    var t = loads(s, func_dict, null);\n    console.assert(JSON.stringify(t) === JSON.stringify({'\"test\"': {}}));\n    \n    s = \"[\\\"abc\\\"]\";\n    t = loads(s, func_dict, null);\n    console.assert(JSON.stringify(t) === JSON.stringify({'abc': {}}));", "0": "var TIME_RE = new RegExp(\"^([0-9]{2}):([0-9]{2}):([0-9]{2})(\\\\.([0-9]{3,6}))?$\");\n\nvar _number_with_underscores = new RegExp('([0-9])(_([0-9]))*');\n\nvar _groupname_re = new RegExp('^[A-Za-z0-9_-]+$');\n\nvar _escapes = [0, 'b', 'f', 'n', 'r', 't', '\"'];\nvar _escapedchars = ['\\0', '\\b', '\\f', '\\n', '\\r', '\\t', '\\\"'];\nvar _escape_to_escapedchars = {};\nfor (var index = 0; index < _escapes.length; index++) {\n    _escape_to_escapedchars[_escapes[index]] = _escapedchars[index];\n}\n\nTEST_STR = `\n[a]\\r\nb = 1\\r\nc = 2\n`\n\nTEST_DICT = {\"a\": {\"b\": 1, \"c\": 2}}\n\ntest();"}